<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android Design Library之二: BottomNavigationView]]></title>
      <url>%2F2017%2F06%2Fandroid-design-library-bottomnavigationview%2F</url>
      <content type="text"><![CDATA[BottomNavitagionView出现之前，我们首先底部的导航栏大多是使用RadioGroup+RadioButton的特性来实现。现在官方为我们提供了另外的一条路。先来尝试下。 Demo打开官方文档里面就有示例程序，比着敲一遍，看下效果。123456789101112&lt;android.support.design.widget.BottomNavigationView android:layout_width="match_parent" android:layout_height="55dp" android:layout_alignParentBottom="true" android:layout_gravity="center" android:gravity="center" app:itemIconTint="#009877" app:itemTextColor="#009877" app:paddingStart="10dp" app:paddingEnd="10dp" app:itemBackground="@color/white" app:menu="@menu/bottom_nav"/&gt; 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/menu_nav_android" android:icon="@drawable/ic_android_black_36dp" app:showAsAction="ifRoom" android:title="Android"/&gt; &lt;item android:id="@+id/menu_nav_lock" android:icon="@drawable/ic_lock_black_36dp" app:showAsAction="ifRoom" android:title="Lock"/&gt; &lt;item android:id="@+id/menu_nav_group_work" android:icon="@drawable/ic_group_work_black_36dp" app:showAsAction="ifRoom" android:title="Work"/&gt;&lt;/menu&gt; 效果如下 嗯。效果还是不错的。但是有时候我们需要的是颜色的变化，这个时候我们需要一个color。在res下的color文件夹下创建一个文件名为bottom_nav的文件内容如下。1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:color="@color/nav_checked" android:state_checked="true"/&gt; &lt;item android:color="@color/nav_unchecked" android:state_checked="false"/&gt;&lt;/selector&gt; 之后为BottomNavitagionView设置上就可以了。效果如下 12app:itemIconTint=&quot;@color/bottom_nav&quot;app:itemTextColor=&quot;@color/bottom_nav&quot; 问题真的就这么就完了么？ too young，too simple。我们底部的菜单项肯定不一定是3个。如果是4个。我们试一下，再加菜单项。很简单为menu再添加个item。来看下效果： WTF 来看下源码看看到底发生了什么？BottomNavigationView的源码1234567891011private final MenuBuilder mMenu;private final BottomNavigationMenuView mMenuView;private final BottomNavigationPresenter mPresenter = new BottomNavigationPresenter();private MenuInflater mMenuInflater;//.....省略代码public void inflateMenu(int resId) &#123; mPresenter.setUpdateSuspended(true); getMenuInflater().inflate(resId, mMenu); mPresenter.setUpdateSuspended(false); mPresenter.updateMenuView(true);&#125; 我们看到。其中主要有这几个属性，通过查看代码我们可以看到。BottomNavigationPresenter来连接Menu和BottomNavigationMenuView的。BottomNavigationPresenter的部分代码123456789101112131415161718private MenuBuilder mMenu;private BottomNavigationMenuView mMenuView;@Overridepublic void initForMenu(Context context, MenuBuilder menu) &#123; mMenuView.initialize(mMenu); mMenu = menu;&#125;....省略...@Overridepublic void updateMenuView(boolean cleared) &#123; if (mUpdateSuspended) return; if (cleared) &#123; mMenuView.buildMenuView(); &#125; else &#123; mMenuView.updateMenuView(); &#125;&#125; 我们可以看到。更新MenuView的方法是通过Presenter来调用的。其内部的代码1234567891011121314151617181920public void buildMenuView() &#123; mShiftingMode = mMenu.size() &gt; 3; for (int i = 0; i &lt; mMenu.size(); i++) &#123; mPresenter.setUpdateSuspended(true); mMenu.getItem(i).setCheckable(true); mPresenter.setUpdateSuspended(false); BottomNavigationItemView child = getNewItem(); mButtons[i] = child; child.setIconTintList(mItemIconTint); child.setTextColor(mItemTextColor); child.setItemBackground(mItemBackgroundRes); child.setShiftingMode(mShiftingMode); child.initialize((MenuItemImpl) mMenu.getItem(i), 0); child.setItemPosition(i); child.setOnClickListener(mOnClickListener); addView(child); &#125; mActiveButton = Math.min(mMenu.size() - 1, mActiveButton); mMenu.getItem(mActiveButton).setChecked(true); &#125; 这里我们应该就看出来端倪了。mShiftingMode是个boolean值，当menu的长度大于三时，就为true。也就为每一个BottomNavigationItemView设置上了child.setShiftingMode(mShiftingMode); true。在这里每一个BottomNavigationItemView就是一个tab。在BottomNavigationItemView的代码中我们可以看到。其填充的布局为R.layout.design_bottom_navigation_item布局中有两个TextView(smallLabel和largeLabel) 和一个ImageView(icon),详细的代码自己搜一下吧。在design包中，这里就不贴出来了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546if (mShiftingMode) &#123; if (checked) &#123; LayoutParams iconParams = (LayoutParams) mIcon.getLayoutParams(); iconParams.gravity = Gravity.CENTER_HORIZONTAL | Gravity.TOP; iconParams.topMargin = mDefaultMargin; mIcon.setLayoutParams(iconParams); mLargeLabel.setVisibility(VISIBLE); ViewCompat.setScaleX(mLargeLabel, 1f); ViewCompat.setScaleY(mLargeLabel, 1f); &#125; else &#123; LayoutParams iconParams = (LayoutParams) mIcon.getLayoutParams(); iconParams.gravity = Gravity.CENTER; iconParams.topMargin = mDefaultMargin; mIcon.setLayoutParams(iconParams); mLargeLabel.setVisibility(INVISIBLE); ViewCompat.setScaleX(mLargeLabel, 0.5f); ViewCompat.setScaleY(mLargeLabel, 0.5f); &#125; mSmallLabel.setVisibility(INVISIBLE); &#125; else &#123; if (checked) &#123; LayoutParams iconParams = (LayoutParams) mIcon.getLayoutParams(); iconParams.gravity = Gravity.CENTER_HORIZONTAL | Gravity.TOP; iconParams.topMargin = mDefaultMargin + mShiftAmount; mIcon.setLayoutParams(iconParams); mLargeLabel.setVisibility(VISIBLE); mSmallLabel.setVisibility(INVISIBLE); ViewCompat.setScaleX(mLargeLabel, 1f); ViewCompat.setScaleY(mLargeLabel, 1f); ViewCompat.setScaleX(mSmallLabel, mScaleUpFactor); ViewCompat.setScaleY(mSmallLabel, mScaleUpFactor); &#125; else &#123; LayoutParams iconParams = (LayoutParams) mIcon.getLayoutParams(); iconParams.gravity = Gravity.CENTER_HORIZONTAL | Gravity.TOP; iconParams.topMargin = mDefaultMargin; mIcon.setLayoutParams(iconParams); mLargeLabel.setVisibility(INVISIBLE); mSmallLabel.setVisibility(VISIBLE); ViewCompat.setScaleX(mLargeLabel, mScaleDownFactor); ViewCompat.setScaleY(mLargeLabel, mScaleDownFactor); ViewCompat.setScaleX(mSmallLabel, 1f); ViewCompat.setScaleY(mSmallLabel, 1f); &#125; &#125; 啊哈。看了这么多终于找到原因了。 这就是问题所在。我们见到如果我们吧mShiftingMode设置为false那么就不会出现那种效果。怎么设置呢。我们可以使用反射的机制来进行设置。代码如下123456789101112131415161718public static void disableShiftMode(BottomNavigationView view) &#123; BottomNavigationMenuView menuView = (BottomNavigationMenuView) view.getChildAt(0); try &#123; Field shiftingMode = menuView.getClass().getDeclaredField("mShiftingMode"); shiftingMode.setAccessible(true); shiftingMode.setBoolean(menuView, false); shiftingMode.setAccessible(false); for (int i = 0; i &lt; menuView.getChildCount(); i++) &#123; BottomNavigationItemView item = (BottomNavigationItemView) menuView.getChildAt(i); item.setShiftingMode(false); item.setChecked(item.getItemData().isChecked()); &#125; &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Design Library之一]]></title>
      <url>%2F2017%2F06%2Fandroid-design-library-1%2F</url>
      <content type="text"><![CDATA[使用Design包后，瞬间感觉自己APP逼格高了呢。妈妈再也不用担心我个人APP设计丑了。 SnackbarSnackbar可以很方便的替换Toast。实现一种更优雅的轻量级提示功能。而且还可以设置Action。在同一时间，只能有一个Snackbar在界面上显示。下面来看下怎么使用：1Snackbar.make(mView, "hello Magicer", Snackbar.LENGTH_SHORT).show(); 简单的一行代码，跟Toast一样。我们还可以通过设置Action来实现轻量级的交互。1234567Snackbar.make(mView, "hello Magicer", Snackbar.LENGTH_SHORT) .setAction("ok", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //点击事件 &#125; &#125;).show(); 不过这个时候，可能你会发现，Snackbar出现的时间太短了,可能来不及点。没有关系。只需要将Snackbar.LENGTH_SHORT换成Snackbar.LENGTH_INDEFINITE。有时候我们需要跟APP设计风格匹配更换其他背景颜色。这个时候也很简单。123456789101112Snackbar snackbar = Snackbar.make(mView, "hello Magicer", Snackbar.LENGTH_INDEFINITE) .setAction("ok", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //点击事件 &#125; &#125;);//更改Snackbar背景颜色snackbar.getView().setBackgroundColor(Color.parseColor("#009688"));//设置Action文字的颜色snackbar.setActionTextColor(Color.parseColor("#9E9E9E"));snackbar.show(); TextInputLayoutTextInputLayout做为EditText的父容器使用，当用户输入内容的时候，hint会移动到上方。使用方法很简单。看下代码。 1234567891011121314151617181920212223242526272829&lt;android.support.design.widget.TextInputLayout android:id="@+id/til_username" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;EditText android:id="@+id/et_username" android:layout_width="match_parent" android:layout_height="match_parent" android:hint="Username"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;android.support.design.widget.TextInputLayout android:id="@+id/til_password" android:layout_width="match_parent" android:layout_height="wrap_content" app:counterEnabled="true" app:counterMaxLength="4" app:counterTextAppearance="@style/counter" app:counterOverflowTextAppearance="@style/counter_over" app:passwordToggleEnabled="true"&gt; &lt;EditText android:id="@+id/et_password" android:layout_width="match_parent" android:layout_height="match_parent" android:hint="Password" android:inputType="textPassword"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 123456&lt;style name="counter"&gt; &lt;item name="android:textColor"&gt;@color/color_teal&lt;/item&gt; &lt;/style&gt; &lt;style name="counter_over"&gt; &lt;item name="android:textColor"&gt;@color/color_red&lt;/item&gt; &lt;/style&gt; 123456789101112131415161718192021mEtUsername.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; if (s.length() &lt;5)&#123; mTilUsername.setError("最少5个字符"); mTilUsername.setErrorEnabled(true); &#125;else &#123; mTilUsername.setErrorEnabled(false); &#125; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); FloatingActionButton来看下FloatingActionButton的集成关系 在来个简单使用的例子123456789&lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;55dp&quot; android:layout_height=&quot;55dp&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_margin=&quot;20dp&quot; app:elevation=&quot;2dp&quot; app:fabSize=&quot;normal&quot; android:src=&quot;@drawable/ic_delete_white_36dp&quot;/&gt; 好了。这货就说这些吧。没什么好些的。详细的方法讲解就看文档呗，没啥好说的。 TabLayout在使用TabLayout的时候，很多时候都是跟ViewPager结合使用。看下结合后的简单例子。 其实实现这种效果也很简单，用不几行代码就搞定了。看下布局文件123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/activity_tab_layout" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tab_layout" android:layout_width="match_parent" android:layout_height="45dp" android:background="#00BCD4" app:tabGravity="fill" app:tabIndicatorColor="#009688" app:tabIndicatorHeight="5dp" app:tabMode="fixed" app:tabSelectedTextColor="#F44336" app:tabTextColor="#FFFFFF"/&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewpager" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/LinearLayout&gt; 其中TabLayout的几个属性的意思为： tabGravity：有两个值：fill表示tab充满屏幕，每个tab均分宽度,center表示根据默认的宽度，tab显示在屏幕中间例如这样 tabIndicatorColor:表示tab底部的指示器的颜色。 tabIndicatorHeight: 表示指示器的高度 tabMode: 有两个值：scrollable表示当tab多了之后可以滚动。fixed宽度固定当数量为9个时fixed会显示成 而为scrollable会显示成详细的方法属性等请看TabLayout官方文档 其他部分代码123456789101112131415161718192021@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_tab_layout); ButterKnife.bind(this); init(); mAdapter = new ImagePageAdapter(mViews); mViewPager.setAdapter(mAdapter); mTabLayout.setupWithViewPager(mViewPager); &#125; private void init() &#123; mViews = new ArrayList&lt;&gt;(); LayoutInflater inflater = LayoutInflater.from(this); for (int i = 0; i &lt; 9; i++) &#123; ImageView view = (ImageView) inflater.inflate(R.layout.item_tab, null); view.setImageResource(R.mipmap.ic_launcher); mViews.add(view); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334public class ImagePageAdapter extends PagerAdapter &#123; private List&lt;View&gt; mViews; public ImagePageAdapter(@NonNull List&lt;View&gt; views) &#123; mViews = views; &#125; @Override public int getCount() &#123; return mViews.size(); &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; container.addView(mViews.get(position)); return mViews.get(position); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView(mViews.get(position)); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return view == object; &#125; @Override public CharSequence getPageTitle(int position) &#123; return "TAB"+position; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Support Annotation的使用]]></title>
      <url>%2F2017%2F06%2Fandroid-support-annotation%2F</url>
      <content type="text"><![CDATA[官方提供了很多特别好用的类或注解，这里说的support annotation就是特别好的工具，多使用其中的注解，可以规范我们的开发，防止一些不必要的错误。要想使用support annotation需要手动添加依赖1compile &apos;com.android.support:support-annotations:25.2.0&apos; 在这里面有几个对我们开发特别有用的注解： @Nullable和@NonNull IntDef StringDef 一些资源类的注解 这里是官方的教程Nullable和NonNull这两个注解还是蛮简单的。字面意思就能看的出来。用于变量，参数和返回值是否为空。例如 123public void foo(@NonNull String content)&#123; &#125; 有这么一个方法，这时候如果我们将参数content的值传入了一个可能为空的值时，编辑器（AS）就会有所提示。 IntDef和StringDef这两个主要是用来解决在Android中使用enum效率低的问题。这是官方的一个demo。在使用到enum的地方，都应该换成IntDef或StringDef。123456789101112131415161718import android.support.annotation.IntDef;public abstract class ActionBar &#123; ... // Define the list of accepted constants and declare the NavigationMode annotation @Retention(RetentionPolicy.SOURCE) @IntDef(&#123;NAVIGATION_MODE_STANDARD, NAVIGATION_MODE_LIST, NAVIGATION_MODE_TABS&#125;) public @interface NavigationMode &#123;&#125; // Declare the constants public static final int NAVIGATION_MODE_STANDARD = 0; public static final int NAVIGATION_MODE_LIST = 1; public static final int NAVIGATION_MODE_TABS = 2; // Decorate the target methods with the annotation @NavigationMode public abstract int getNavigationMode(); // Attach the annotation public abstract void setNavigationMode(@NavigationMode int mode); 资源类注解通过自带的几个资源类注解，可以做到在代码中提示我们使用的资源是否正确。作用在参数上。主要有@StringRes @DimenRes @IdRes @ColorRes @DrawableRes @AnimRes @AttrRes@LayoutRes @MenuRes @RawRes等 各类资源的检查注解。例如，在使用@StringRes之后，会检查该值是不是R.string的形式。 其他要想查看更加详细的注解，就查看官方文档吧。官方文档讲的比我清楚明了。这里就是简单提一下，做个小笔记。 值约束注解 IntRange FloatRange等，详细看官方文档。这里的代码摘抄自官方文档 1public void setAlpha(@IntRange(from=0,to=255) int alpha) &#123; … &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android.util包下的几个集合类 SparseArray和ArrayMap等]]></title>
      <url>%2F2017%2F06%2Fandroid-utils-sparsearray-arrayymap%2F</url>
      <content type="text"><![CDATA[在Android开发中我们大部分时候都是使用Java语言中的HashMap来存储数据，但是当开发Android应用的时候，可能效率并不好，因此Android官方实现了几个适合在Android平台使用的集合类。那么这些Android自己实现的集合类有什么优势呢？下面我们逐一看一下。 ArrayMap123456ArrayMap&lt;String ,String&gt; arrayMap = new ArrayMap&lt;&gt;();arrayMap.put(&quot;a&quot;,&quot;A&quot;);arrayMap.put(&quot;b&quot;,&quot;B&quot;);arrayMap.put(&quot;a&quot;,&quot;A&quot;);arrayMap.put(&quot;c&quot;,&quot;C&quot;);Log.i(TAG, &quot;init: &quot;+arrayMap.toString()); ArrayMap的使用跟HashMap是一样的。当数据结构为的时候，都可以使用ArrayMap替代。但是相较于HashMap，ArrayMap在Android中也不总是高效的。当数据量大了（数百）之后，其性能就会下降至少50%。所以，当数据量小的时候，使用ArrayMap效率还是蛮高的，比较是官方专门为Android写的。 SparseArray在开发中有时我们也会看到Lint让我们使用其他的如SparseArray等替换的提示。 这个时候替换的话一般会得到很好的性能优化。 SparseArray也是用一个对，但是跟ArrayMap不同的是，这里的Key是Integer.并且省去了自动装箱的操作。提高了存取效率。使用如下123456SparseArray&lt;String&gt; sparseArray = new SparseArray&lt;&gt;();sparseArray.put(1,"A");sparseArray.put(2,"B");sparseArray.put(3,"C");sparseArray.put(2,"D");Log.i(TAG, "init: "+sparseArray.toString()); 其他 SparseIntArray：当map的结构为Map&lt;Integer,Integer&gt;的时候使用，效率较高。 SparseBooleanArray: 当map的结构为Map&lt;Integer,Boolean&gt;的时候使用，效率较高。 SparseLongArray: 当map的结构为Map&lt;Integer,Long&gt;的时候使用，效率较高。 LongSparseArray: 当map的结构为Map&lt;Long,Value&gt;的时候使用，效率较高。 ArraySet：和ArrayMap的目的类似，用来提高HashSet的效率。使用方法跟HashSet类似 最后说一点，对于android.util包下的这些容器类，是在API 19以后才引入的，要想在之前的版本中使用需要引用android.support.v4.util包下的相应容器类。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android小白研究下Bitmap]]></title>
      <url>%2F2017%2F06%2Fandroid-bitmap%2F</url>
      <content type="text"><![CDATA[在Android开发中我们会在很多时候用到图片，这个时候我们就需要用到Bitmap了，在Android开发中我们使用的图都要转换成位图。但是我们并不能通过Bitmap的构造方法来实例化一个Bitmap，官方提供了BitmapFactory来的静态方法来实例化Bitmap。当我们使用Bitmap的时候很容易的就会导致应用程序的内存被消耗完，所以使用Bitmap的时候一定要做好优化。 Config在Bitmap类的内部有个Config枚举：1234567891011121314151617181920212223public enum Config &#123; /** *每一个像素存一个alpha通道的值，不存储颜色信息，适合做遮罩层。每个像素占1byte。 */ ALPHA_8 (1), /** *每个像素占2byte，只有RBG通道色值，Red占5bit，Green占6bit，Blue占5bit。 */ RGB_565 (3), /** *因为质量太低，推荐使用ARGB_8888代替 */ @Deprecated ARGB_4444 (4), /** * 官方推荐使用 *每一个像素占4byte，每一个通道（ARGB）占8bit（256个值）. *灵活切画面质量好 */ ARGB_8888 (5); &#125; 他的主要作用就是让我们来设置画面的质量的， 创建一个Bitmap查看bitmap的源码我们会看到一些createBitmap()方法，但是我们创建Bitmap使用的最多的是BitmapFactory类的方法。1Bitmap bitmap = Bitmap.createBitmap(mWidth,mHeight, Bitmap.Config.ARGB_8888); 通过上面的方法可以创建一个空白的Bitmap。 BitmapFactoryOptions类Options类用来设置解码的参数。其中主要有： public Bitmap inBitmap; public boolean inJustDecodeBounds; 如果设置为true，解析器将返回null，但是out...字段会设置上值。 public int inSampleSize; 如果设置的值&gt;1那么解析器将会对原始图片进行抽取，返回一个更小的图片。解析器会使用2的次方，其他的值会向下转为最近的2的幂。 public boolean inDither; public int inDensity; bitmpa使用的像素密度。 public int inTargetDensity; public int inScreenDensity; public boolean inScaled; public int outWidth; 图片的宽度 public int outHeight; 图片的高度 public String outMimeType; 如果知道图片的MIME类型就设置上，如果不知道就设置为null 当我们想对图片进行压缩的时候，我们就要使用到Options。先看下代码：12345678910111213141516171819202122232425262728293031 BitmapFactory.Options options = new BitmapFactory.Options(); //设置为true，先让解析器解析出图片的大小信息。 options.inJustDecodeBounds = true; BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher,options); //之后他们通过这个得到了图片大小信息的options来计算压缩的比例。 options.inSampleSize = calculateInSampleSize(options,200,200); options.inJustDecodeBounds = false; //之后设置为false，为了获取到bitmap。 Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher, options);//之后就可以通过这个options来获取自己期望的bitmap了。 public static int calculateInSampleSize( BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; // Raw height and width of image final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; final int halfHeight = height / 2; final int halfWidth = width / 2; // Calculate the largest inSampleSize value that is a power of 2 and keeps both // height and width larger than the requested height and width. while ((halfHeight / inSampleSize) &gt;= reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) &#123; inSampleSize *= 2; &#125; &#125; return inSampleSize;&#125; 这里的calculateInSampleSize方法是官方文档中提供的用来计算InSampleSize值的方法。 decode方法使用decode系列方法来得到bitmap对象 Recycle 当Bitmap不再使用的时候记得将其回收，以免内存泄漏123if (!bitmap.isRecycled()) &#123; bitmap.recycle(); &#125; 复制BitmapBitmap有一个coty()方法用来复制一个Bitmap.源码如下123456789101112131415161718192021/** * Tries to make a new bitmap based on the dimensions of this bitmap, * setting the new bitmap's config to the one specified, and then copying * this bitmap's pixels into the new bitmap. If the conversion is not * supported, or the allocator fails, then this returns NULL. The returned * bitmap initially has the same density as the original. * * @param config The desired config for the resulting bitmap * @param isMutable True if the resulting bitmap should be mutable (i.e. * its pixels can be modified) * @return the new bitmap, or null if the copy could not be made. */ public Bitmap copy(Config config, boolean isMutable) &#123; checkRecycled("Can't copy a recycled bitmap"); Bitmap b = nativeCopy(mNativePtr, config.nativeInt, isMutable); if (b != null) &#123; b.setPremultiplied(mRequestPremultiplied); b.mDensity = mDensity; &#125; return b; &#125; 有时我们创建的Bitmap是无法更改的。但是有时候我们可能需要对Bitmap进行更改，这个时候我们就可以使用copy（Config,true）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[greenDao多表关联]]></title>
      <url>%2F2017%2F06%2Fgreendao3-relations%2F</url>
      <content type="text"><![CDATA[之前我们看到了greenDao的简单使用，但是就这些是远远不够的，有时候我们需要存储的数据较为复杂，这个时候我们可能需要使用到多表关联的操作。 ToOne一对一的关系映射。看个例子：1234567891011121314151617181920212223242526272829@Entitypublic class Score &#123; @Id private String id; private int score;&#125;@Entitypublic class Student &#123; @Id private String id; private String name; private int age; private String scoreId; @ToOne(joinProperty = "scoreId") private Score score;&#125; //先向数据库中插入两条数据 Score score = new Score("1101", 80); Student magicer = new Student("110","Magicer",12,"1101"); scoreDao.insertOrReplace(score); studentDao.insertOrReplace(magicer); //之后查找我们插入的数据，就可以查询出来我们想要的带有成绩的学生实体。 QueryBuilder&lt;Student&gt; queryBuilder = studentDao.queryBuilder().where(StudentDao.Properties.Name.eq("Magicer")); for (Student student : queryBuilder.list()) &#123; Log.i(TAG, "onCreate: "+student.toString()); &#125; 在上面的例子中，我们设定每个学生有一门成绩，这个时候就是个ToOne一对一的关系。我们通过joinProperty来设置外键。我们就可以很方便的查询出某个学生的成绩了。1234567public @interface ToOne &#123; /** * Name of the property inside the current entity which holds the key of related entity. * If this parameter is absent(缺少的), then an additional column is automatically created to hold the key. */ String joinProperty() default "";&#125; ToMany但是一般一个学生会有多个成绩，这个时候我们就需要使用ToMany一对多的关系了。先看下例子： 12345678910111213141516171819202122232425262728293031323334@Entitypublic class Student &#123; @Id private String id; private String name; private int age; @ToMany(referencedJoinProperty = "studentId") private List&lt;Score&gt; scores;&#125;@Entitypublic class Score &#123; @Id private String id; private int score; private String type; private String studentId;&#125; Score math = new Score("1101", 87, "Math", "110"); Score english = new Score("1102", 99, "English", "110"); Score chinese = new Score("1103", 120, "Chinese", "110"); scoreDao.insertOrReplaceInTx(math,english,chinese);//使用事务插入或替换数据 Student magicer = new Student("110", "Magicer", 23); studentDao.insertOrReplace(magicer); Query&lt;Student&gt; query = studentDao.queryBuilder().where(StudentDao.Properties.Name.eq("Magicer")).build(); for (Student student : query.list()) &#123; Log.i(TAG, "onCreate: "+student); &#125;//I/MainActivity: onCreate: Student&#123;id='110', name='Magicer', age=23, score=[Score&#123;id='1101', score=87, type='Math', studentId='110'&#125;, Score&#123;id='1102', score=99, type='English', studentId='110'&#125;, Score&#123;id='1103', score=120, type='Chinese', studentId='110'&#125;]&#125; 这个时候，一个学生就有Math Enghlish Chinese三个的成绩。这个时候，我们使用referencedJoinProperty将成绩跟学生建立了关联关系。 12345678910111213public @interface ToMany &#123; /** * Name of the property inside the target entity which holds id of the source (current) entity * Required unless no &#123;@link JoinProperty&#125; or &#123;@link JoinEntity&#125; is specified */ String referencedJoinProperty() default ""; /** * Array of matching source -&gt; target properties * Required unless &#123;@link #referencedJoinProperty()&#125; or &#123;@link JoinEntity&#125; is specified */ JoinProperty[] joinProperties() default &#123;&#125;;&#125; JoinEntity有时我们还要创建多对多的关联关系N:M。在greenDao中就使用JoinEntity注解；先来看下他的定义：12345678910public @interface JoinEntity &#123; /** Reference to join-entity class, which holds the source and the target properties */ Class&lt;?&gt; entity(); /** Name of the property inside the join entity which holds id of the source (current) entity */ String sourceProperty(); /** Name of the property inside the join entity which holds id of the target entity */ String targetProperty();&#125; 配置多对多关系的时候我们需要使用到ToMany和JoinEntity通过JoinEntity注解来配置关联的建。如下： 123456789101112131415161718192021222324252627282930@Entitypublic class Student &#123; @Id private String id; private String name; private int age; @ToMany @JoinEntity( entity = Join.class, sourceProperty = "studentId", targetProperty = "scoreId" ) private List&lt;Score&gt; scores;&#125;@Entitypublic class Join &#123; @Id private String id; private String studentId; private String scoreId;&#125;@Entitypublic class Score &#123; @Id private String id; private int score; private String type; private String studentId;&#125; 遇到的问题当插入到数据库中的数据是网络请求得到的时候会有些注意事项。由于greenDao会帮助我们生成一些get和set方法。这个是时候就要注意了。来看下生成的代码：1234567891011121314151617@Entitypublic class Point &#123; @Id private Long id; private Long strokeId; private int x; private int y;&#125;@Entitypublic class Stroke &#123; @Id private Long id; private String name; @ToMany(referencedJoinProperty = "strokeId") private List&lt;Point&gt; points;&#125; 如上面，我们现在有每个笔画Stroke会有很多的Point。编译下之后会生成很多get和set方法。我们看下Stroke的一个get方法我们会看到下面这些代码。就由于这个代码。可能就会导致。我们解析到了Stroke后调用getPoints()方法想要获取点的集合是出现问题，这时候就可能会报错。这个时候我们可以在单独写另外的一个get方法，来支持直接获取points对象。1234567891011121314151617@Generated(hash = 404164872) public List&lt;Point&gt; getPoints() &#123; if (points == null) &#123; final DaoSession daoSession = this.daoSession; if (daoSession == null) &#123; throw new DaoException("Entity is detached from DAO context"); &#125; PointDao targetDao = daoSession.getPointDao(); List&lt;Point&gt; pointsNew = targetDao._queryStroke_Points(id); synchronized (this) &#123; if(points == null) &#123; points = pointsNew; &#125; &#125; &#125; return points; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[greenDao使用进阶]]></title>
      <url>%2F2017%2F06%2Fgreendao3-advanced%2F</url>
      <content type="text"><![CDATA[在之前的一遍greenDao基础使用中学习了greenDao的集成及简单的使用，现在开启进阶之路。学习下使用中的细节。 Annotations在之前的配置中我们使用到了@Entity和@Id注解,除了这俩greenDao中还有其他注解来方便我们配置数据库。下面一一介绍 123456789101112@Entitypublic class Student &#123; @Id private String id; @NotNull private String name; @Property(nameInDb = "student_age") private int age; @Transient private String address;&#125; @Entity我们使用Entity注解来指定 为某个类创建一个表。下面是Entity的源码，我们可以从中看到在制定表的时候我们可以设置很多参数。 123456789101112131415161718192021222324252627282930313233public @interface Entity &#123; /** * Specifies the name on the DB side (e.g. table name) this entity maps to. By default, the name is based on the entities class name. */ String nameInDb() default ""; /** * Indexes for the entity. * &lt;p/&gt; * Note: To create a single-column index consider using &#123;@link Index&#125; on the property itself */ Index[] indexes() default &#123;&#125;; /** * Advanced flag to disable table creation in the database (when set to false). This can be used to create partial * entities, which may use only a sub set of properties. Be aware however that greenDAO does not sync multiple * entities, e.g. in caches. */ boolean createInDb() default true; /** * Specifies schema name for the entity: greenDAO can generate independent sets of classes for each schema. * Entities which belong to different schemas should &lt;strong&gt;not&lt;/strong&gt; have relations. */ String schema() default "default"; /** * Whether update/delete/refresh methods should be generated. * If entity has defined &#123;@link ToMany&#125; or &#123;@link ToOne&#125; relations, then it is active independently from this value */ boolean active() default false;&#125; 一般来说我们只需要使用@Entity就可以满足我们的需求了。 @Id将某个属性设置为主键（primary key)。也可以为Long/long类型的值制定自增长。如下： 12@Id(autoincrement = true) private Long id; autoincrement只有在类型为Long/long的时候起作用。 @NotNull指定某个字段不能为空。 @Property通过该注解可以为设置在数据库中的列名 12@Property(nameInDb = "student_age") private int age; 通过上面的代码就会把age对应的数据存到student_age列中。 @Transient配置了该注解的属性将不会存到数据库中。 CRUD通过上面的几个注解我们已经可以让greenDao自动生成操作数据库的各种语句了。接下来就是最重要的数据库CRUD操作了。以下的CRUD操作使用这个类作为例子。 12345678@Entitypublic class Question &#123; @Id private String id; @NotNull private String content; private Long start; &#125; 1234DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this,&quot;greendao.db&quot;,null);SQLiteDatabase db = helper.getWritableDatabase();DaoMaster daoMaster = new DaoMaster(db);DaoSession daoSession = daoMaster.newSession(); Create 上图显示了插入数据库的方法。Tx结尾的是使用事务提交的。插入到数据库时我们是直接使用生成的Dao文件来操作的。以下的实例展示了向数据库中插入一条数据： 123QuestionDao questionDao = daoSession.getQuestionDao();Question question = new Question(UUID.randomUUID().toString(), "这是题目的内容", System.currentTimeMillis());questionDao.insert(question); Update Delete 上图展示了删除的方法。 delete(Question entity)方法是根据查询entity的key之后调用deleteByKey(String key)方法删除的。 Retrieve接下来就是数据库中最重要的查找方法了。在greenDao中查找数据库也很方便，在基础中我们也看到了。下面详细的来看下。 QueryBuilder 从图中我们看出QueryBuilder有很多的方法供我们选择。方法太多了就不一一介绍了。详细的文档看着里吧 123456Query&lt;Question&gt; build = questionDao.queryBuilder() .where(QuestionDao.Properties.Id.eq("1001")) .build();for (Question question : build.list()) &#123; Log.i(TAG, "onCreate: "+question.toString());&#125; where()是用来配置我们的查询条件的。可以传递的多查询条件，将会使用AND语句查询。在上面的例子中我们看到了QuestionDao.Properties.Id.eq(&quot;1001&quot;)这是用来配置查询条件的。主要有:(详细的文档看着里：官方文档) eq： equals 相等 notEq： 不等 like： SQL语句中的LIKE ?语句。 想要学习有关LIKE语法可以看这里 between SQL语句中的BETWEEN ... AND ... BETWEEN 语法学习看这里 in: IN语法学习看这里 notIn: gt: greater than (&#39;&gt;&#39;) lt: less than (&#39;&lt;&#39;) ge: greater or equal (&#39;&gt;=&#39;) le: less or equal (&#39;&lt;=&#39;) isNull: isNotNull]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[greenDao基础使用]]></title>
      <url>%2F2017%2F05%2Fgreendao3-basic%2F</url>
      <content type="text"><![CDATA[greenDao官方文档中介绍，其效率要优于其他几个ORM框架，也有小伙伴验证过，其效率确实挺不错。所以greenDao还是有必要学一学的。毕竟只是用Android的SQLiteOpenHelper效率不是低了一丁点。在学习了greenDao之后感觉还是蛮好用的。在这里记录下使用方法。 集成 在一开始学习的使用，查看官方文档。没有找到greenDao的完成配置方式。可能是我不够细心。下面是完全的greedDao的配置。想要查看配置的请点这里在build.gradle文件中添加：1234567891011apply plugin: &apos;org.greenrobot.greendao&apos; greendao &#123; schemaVersion 1 daoPackage &apos;xyz.magicer.greendaodemo.dao&apos; //包名 targetGenDir &apos;src/main/java&apos; //生成目录 &#125; compile &apos;org.greenrobot:greendao:3.2.0&apos; compile &apos;org.greenrobot:greendao-generator:3.2.0&apos; 在项目中的build.gradle中添加12345678910111213buildscript &#123; repositories &#123; jcenter() mavenCentral() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.2.2&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.1&apos; &#125;&#125; 使用官方文档中关于部分注解的说明：点这里 创建entity文件1234567891011121314151617181920212223242526272829303132@Entitypublic class User &#123; @Id private long id; private String name; private int age; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public long getId() &#123; return this.id; &#125; public void setId(long id) &#123; this.id = id; &#125;&#125; 编译编译一下工程之后就会生成DaoMaster、DaoSession、UserDao三个文件。 使用一个简单的使用实例如下。1234567891011DaoMaster.DevOpenHelper openHelper = new DaoMaster.DevOpenHelper(this, "user.db", null);DaoMaster daoMaster = new DaoMaster(openHelper.getWritableDatabase());DaoSession daoSession = daoMaster.newSession();UserDao userDao = daoSession.getUserDao();User user = new User(0, "zhang3", 19);userDao.insert(user);List&lt;User&gt; magicer= userDao.queryBuilder().where(UserDao.Properties.Name.eq("magicer")) .orderDesc() .build() .list(); ClassCastExceptionSchema.java1java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.Long 参考 官方文档 官方源码 GIT]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OkHttp3学习（三）：execute和Interceptor]]></title>
      <url>%2F2017%2F05%2Fokhttp-execute-intercptor%2F</url>
      <content type="text"><![CDATA[回顾 在OkHttp3学习（二）：发送一个请求中 我们看到了当我们发送一个请求时，通过client.newCall(request)来创建一个RealCall实例，当我们调用RealCall的execute()的时候会调用client对象的dispatcher的execute()方法来执行这个RealCall。当我们调用了RealCall的enqueue()方法之后会在内部调用Client对象的dispatcher的execute()方法时创建一个AsyncCall对象,并执行这个AsyncCall的execute方法。不管是client.newCall(request).execute()还是client.newCall(request).enqueue(new Callback(){})我们会发现对应的Call的execute()都会得到执行。 execute() 既然RealCall和AsyncCall的execute()都会得到执行，那他们又有什么共同之处呢，相应又是怎么获得的呢？这是RealCall的execute() 去除了部分代码之后的12345678910@Override public Response execute() throws IOException &#123; captureCallStackTrace(); try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; 这是AsyncCall去掉部分代码后的execute()1234567891011121314@Override protected void execute() &#123; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; //... &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; 在这两个代码中我们看到。请求的响应(Responce)都是通过getResponseWithInterceptorChain()方法获取的。其代码是这样的：1234567891011121314151617Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); &#125; 在这些代码中我们看到了一堆的Interceptor那么这又是个什么鬼呢？ Interceptor官方关于Interceptor的介绍：点这里看下这个图。看下这个例子自定义一个Inteceptor应该不成问题了。例子在文档中有。123456789101112131415161718192021222324252627282930313233/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */final class GzipRequestInterceptor implements Interceptor &#123; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request originalRequest = chain.request(); if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) &#123; return chain.proceed(originalRequest); &#125; Request compressedRequest = originalRequest.newBuilder() .header("Content-Encoding", "gzip") .method(originalRequest.method(), gzip(originalRequest.body())) .build(); return chain.proceed(compressedRequest); &#125; private RequestBody gzip(final RequestBody body) &#123; return new RequestBody() &#123; @Override public MediaType contentType() &#123; return body.contentType(); &#125; @Override public long contentLength() &#123; return -1; // We don't know the compressed length in advance! &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; BufferedSink gzipSink = Okio.buffer(new GzipSink(sink)); body.writeTo(gzipSink); gzipSink.close(); &#125; &#125;; &#125;&#125; 通过下面的方法将一个自定义的Inteceptor加入到请求中。123456789101112131415OkHttpClient client= new OkHttpClient .Builder() .addInterceptor(new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; return null; &#125; &#125;) .addNetworkInterceptor(new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; return null; &#125; &#125;).build();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OkHttp3学习（二）：发送一个请求]]></title>
      <url>%2F2017%2F03%2Fokhttp3-basic-2%2F</url>
      <content type="text"><![CDATA[在OkHttp3学习(一)：基本使用中记录了怎么使用OkHttp设置一个指定的请求，我们请求的参数有了，之后我们就是发起请求了。那么OkHttp3又是怎么发起的这次请求呢？ 先看下之前的一个GET请求123456789101112131415161718OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .get() .url(PATH) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; String string = response.body().string(); Log.i(TAG, "onResponse: "+string); &#125; &#125; &#125;); 在这次请求中我们设置好Request请求的相关参数之后，我们就调用了。client.newCall(request)。从字面意思猜测这个newCall就是在创建一次新的请求。 CallCall是一个接口,源码是这样的。(OkHttpClient实现了Call.Factory接口)1234567891011121314151617181920public interface Call extends Cloneable &#123; Request request(); //返回发起这个Call的原始Request Response execute() throws IOException; //执行请求 void enqueue(Callback responseCallback); //在以后的某个时间点执行 void cancel(); //取消请求 如果请求已经成功了就不能取消了 boolean isExecuted(); //是否正在执行 boolean isCanceled(); //是否取消了 Call clone(); interface Factory &#123; Call newCall(Request request); &#125;&#125; newCall 来看下client.newCall(request)都干了些什么。123456/** * Prepares the &#123;@code request&#125; to be executed at some point in the future. */ @Override public Call newCall(Request request) &#123; return new RealCall(this, request, false /* for web socket */); &#125; 通过源码看到。在这里我们是创建了一个RealCall的实例。之后我们又调用了RealCall的enqueue()。来看下。1234567891011121314151617181920212223 @Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException("Canceled"); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125;@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; 进入方法，先判断是否执行了。之后调用了captureCallStackTrace()，之后我们就看到了。这次请求是通过OkHttpClient的Dispatcher调度器执行的。（client.dispatcher()返回OkHttp的成员变量Dispatcher）。我们看到enqueue()和executed()都是调用了Dispatcher的方法。12345678910111213/** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */ synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call); &#125; synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call); &#125; &#125; 在这部分代码中。runningAsyncCalls异步请求的双端队列。 runningSyncCalls同步请求的双端队列。尽管RealCall和AsyncCall都叫做Call。但是还是有点区别的。AsyncCall是Runnable的间接子类并没有实现Call接口或者集成Call，而RealCall则是一个Call的子类。他们有着本质上的区别。12345/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running synchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); AcyncCall在上面的代码中我们可以看到enqueue在执行的时候是同过executorService()来执行的。该方法会返回一个ExecutorService，同事也初始化了Dispatcher中的executorService变量。1234567public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false)); &#125; return executorService; &#125; Dispatcher通过这个execurorService来管理着所有异步请求（AcyncCall）。同步请求是通过调用RealCall的execute()方法执行的，异步请求是通过AsyncCall的execute来执行的。不过AsyncCall的execute()是在父类NamedRunnable的run()方法中调用的，也就是由线程池来管理着。分析AsyncCall和RealCall的execute()方法我们会看到，都会执行123finally &#123; client.dispatcher().finished(this); &#125; 都执行了Dispatcher的finished()函数，来看下：123456789101112131415161718192021222324/** Used by &#123;@code AsyncCall#run&#125; to signal completion. */ void finished(AsyncCall call) &#123; finished(runningAsyncCalls, call, true); &#125; /** Used by &#123;@code Call#execute&#125; to signal completion. */ void finished(RealCall call) &#123; finished(runningSyncCalls, call, false); &#125; private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!"); if (promoteCalls) promoteCalls(); runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125; &#125; 从双端队列中取出call，如果是AsyncCall就执行promoteCalls()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OkHttp3学习(一)：基本使用]]></title>
      <url>%2F2017%2F03%2Fokhttp3-basic-1%2F</url>
      <content type="text"><![CDATA[An HTTP &amp; HTTP/2 client for Android and Java applications引用自官方文档 GET &amp;&amp; POST什么都不管，先上个代码。敲完再说。 GET12345678910111213141516171819OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .get() .url(PATH) .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful()) &#123; String string = response.body().string(); Log.i(TAG, "onResponse: "+string); &#125; &#125;&#125;); 上面的图中显示了response.body()可以得到的数据类型。在上面的例子中我们使用了string()来得到了相应的字符串数据。需要注意的是这里的回调不在主线程.如果需要更新UI。我们还需要切换到主线程进行操作。 POST这是一个异步调用的例子。123456789101112131415161718192021MediaType jsonType = MediaType.parse("application/json; charset=utf-8");OkHttpClient client = new OkHttpClient();String jsonStr = new Gson().toJson(mPerson);RequestBody body = RequestBody.create(jsonType,jsonStr);Request request = new Request.Builder() .post(body) .url(PATH) .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; if (response.isSuccessful())&#123; String string = response.body().string(); Log.i(TAG, "post: "+string); &#125; &#125;&#125;); 请求大致过程 我们每次做请求的时候都要有一个OkHttpClient实体，用来构建我们的一次请求。而Request类用来设置我们请求需要的参数，之后我们就可以通过client来发送一个请求了。在上面的例子中，我们将请求加入到了一个请求队列中(enqueue)。最后我们就得到了这次请求的响应response了。 Request在构建Request的时候，使用到了Builder设计模式。只需要简单的链式调用配置好请求参数。如下：12345Request request = new Request.Builder().url(PATH) .header("User-Agent", "my-agent") .addHeader("Accept-Language", "zh-cn") .get() .build(); header &amp;&amp; addHeaderheader和addHeader用来添加头部字段的key-value对。12345678910111213141516171819/** * Sets the header named &#123;@code name&#125; to &#123;@code value&#125;. If this request already has any headers * with that name, they are all replaced. */public Builder header(String name, String value) &#123; headers.set(name, value); return this;&#125;/** * Adds a header with &#123;@code name&#125; and &#123;@code value&#125;. Prefer this method for multiply-valued * headers like "Cookie". * * &lt;p&gt;Note that for some headers including &#123;@code Content-Length&#125; and &#123;@code Content-Encoding&#125;, * OkHttp may replace &#123;@code value&#125; with a header derived from the request body. */public Builder addHeader(String name, String value) &#123; headers.add(name, value); return this;&#125; 我们看到，这两个函数底层一个是使用的Header.Builder的set()，一个是使用的add().在继续往里看：12345678910111213141516/** * Set a field with the specified value. If the field is not found, it is added. If the field is * found, the existing values are replaced. */ public Builder set(String name, String value) &#123; checkNameAndValue(name, value); removeAll(name); addLenient(name, value); return this; &#125; /** Add a field with the specified value. */ public Builder add(String name, String value) &#123; checkNameAndValue(name, value); return addLenient(name, value); &#125; 这就很清晰了。很明显了。set()调用了removeAll(key)方法来删除之前设置了同名的key。而add并没有删除。其实从名字我们就可以看出来。add就是添加嘛。set设置，肯定只有一个嘛。 RequestBody12345678910111213141516171819OkHttpClient client =new OkHttpClient();MediaType parse = MediaType.parse("application/json; charset=utf-8");RequestBody body = RequestBody.create(parse,new Gson().toJson(mPerson));Request request = new Request.Builder().url(PATH) .header("User-Agent", "my-agent") .addHeader("Accept-Language", "zh-cn") .post(body) .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125;&#125;); 将上面的请求通过抓包工具抓取后，下图即为本次的请求。 ResponseBody是一个抽象类。在okhttp中的子类有FormBody和MultipartBody。 我们可以通过静态方法create来构建一个ResponseBody。 ResponseBody内部的create可以通过三中方式构建。当然了。我们也可以模仿官方的crete方法来构建自己的ResponseBody来上传制定类型的文件。我们通过MediaType来指定我们上传文件的类型。比如上面代码中的&quot;application/json; charset=utf-8&quot;就是我们上传的内容的类型。当我们有什么文件想要提交，但是不知道key是什么的时候可以看MIME 参考手册 FormBody 用来提交一些表单数据。通过FormBody.Builder来添加表单数据。如下所示：12345678910OkHttpClient client = new OkHttpClient();FormBody formBody = new FormBody.Builder() .add("username", "jason") .add("password", "magicer") .build();Request request = new Request.Builder() .post(formBody) .addHeader("User-Agent", "Apple") .build();Response response = client.newCall(request).execute(); 在FromBody中，查看其源码我们可以看到FormBody设置的Content-Type为&quot;application/x-www-form-urlencoded&quot;.也就是普通表单数据。12private static final MediaType CONTENT_TYPE = MediaType.parse("application/x-www-form-urlencoded"); MultipartBody 以下是MultipartBody中的一些个类型。12345public static final MediaType MIXED = MediaType.parse("multipart/mixed");public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");public static final MediaType DIGEST = MediaType.parse("multipart/digest");public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");public static final MediaType FORM = MediaType.parse("multipart/form-data");]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android EditText禁止输入Emoji后设置android:maxLength失效的问题]]></title>
      <url>%2F2017%2F03%2Fandroid-edittext-emoji%2F</url>
      <content type="text"><![CDATA[0X00 禁用emoji有时候我们不想在EditText中输入Emoji表情，怎么处理呢？我们可以通过设置InputFilter的方式来达到这个目的。怎么实现呢？直接上代码。123456789101112131415public InputFilter emojiFilter = new InputFilter() &#123; @Override public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) &#123; for (int index = start; index &lt; end; index++) &#123; int type = Character.getType(source.charAt(index)); if (type == Character.SURROGATE) &#123; return ""; &#125; &#125; return null; &#125; &#125;; 0X01 问题但是当我们设置了InputFilter之后可能会出现一个问题，就是当我们在代码中设置android:maxLength=&quot;8&quot;的时候，会发现不起作用了。我们点进去InputFilter，查看其源码我们就会发现，里面还有个自带的LengthFilter。我们就可以通过再添加一个LengthFileter就可以了。1editText.setFilters(new InputFilter[]&#123;new InputFilter.LengthFilter(8), emojiFilter&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NoClassDefFoundError: android/os/PersistableBundle]]></title>
      <url>%2F2017%2F03%2Feventbus-NOClassDefFoundError%2F</url>
      <content type="text"><![CDATA[EventBus问题之前程序运行的好好的。但是测试拿去了之后就是崩了。查看了下日志。原来是报EventBus的一个错误。在这里记录下。1java.lang.NoClassDefFoundError: android/os/PersistableBundle 在网上搜索了下说是我OnCreate写错了。查看了一下。改成了protected的就可以了。 1234@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; 报错的OnCreate@Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) { super.onCreate(savedInstanceState, persistentState); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学习计划]]></title>
      <url>%2F2017%2F03%2Ftask%2F</url>
      <content type="text"><![CDATA[2017年 &nbsp; &nbsp; Golang基本语法 &nbsp; beego &nbsp; 用go搭建个服务器 &nbsp; 设计模式 &nbsp; RxJava &nbsp; OkHttp 源码 &nbsp; 各类自定义View &nbsp; 动画特效的实现]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个Android程序猿的Golang学习之路: 结构体和方法]]></title>
      <url>%2F2017%2F03%2Fgolang-struct-basic%2F</url>
      <content type="text"><![CDATA[Golang中的struct有点跟Java中的类相似. struct管他什么特性不特性的,先来段代码.看看跟学过的其他语言有啥区别. 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot;)type Person struct &#123; name string age int&#125;type Student struct &#123; grade string Person //匿名字段&#125;func main() &#123; stu := new(Student) var stu2 Student = Student&#123;&quot;一年级&quot;, Person&#123;&quot;Arya Stark&quot;, 15&#125;&#125; stu3 := Student&#123;grade: &quot;二年级&quot;, Person: Person&#123;&quot;Magicer&quot;, 32&#125;&#125; stu.grade = &quot;三年级&quot; stu.Person = Person&#123;&quot;Jon Snow&quot;, 33&#125; fmt.Println(stu) //输出 &amp;&#123;三年级 &#123;Jon Snow 33&#125;&#125; //在这里可以直接stu.name获得匿名字段的值,也可以stu.Person.name fmt.Println(stu.name, stu.age, stu.grade, stu.Person) //输出Jon Snow 33 三年级 &#123;Jon Snow 33&#125; fmt.Println(stu2) //输出 &#123;一年级 &#123;Arya Stark 15&#125;&#125; fmt.Println(stu3) //输出 &#123;二年级 &#123;Magicer 32&#125;&#125;&#125; Golang中没有继承,但是我们可以使用组合的方式来实现和继承类似的效果.比如上面的代码.我们不能通过显示的让Student继承自Person但是我们可以通过组合的方式来得到这种效果. type我们可以通过type关键字来定义一个类型.比如这里的Person类型和Student类型.我们还可以通过type关键字来为int等来设置别名 如type grade int.通过type关键字来定义的 方法先来段跟方法有关的代码,看下Golang中的方法是个什么鬼.12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot;)type Student struct &#123; name string age int&#125;//值方法//当我们不需要在方法中使用这个结构的值的时候, 可以使用_func (_ Student) lean() &#123; fmt.Println(&quot;Student lean&quot;)&#125; //指针方法//这里的(stu *Student)用来表示这个方法是属于谁的.可以位于不同的文件中,只要是在同一个包中就可以//在这里我们的stu是Student的指针,只有这时候我们才可以修改p的值,// 当使用(stu Student)时,我们使用的是一份copy.func (stu *Student) eat(food string) &#123; fmt.Println(stu.name, &quot; eat &quot;, food, &quot;\t &quot;, stu)&#125;func main() &#123; stu := new(Student) stu.eat(&quot;Apple&quot;) //student eat Apple &amp;&#123; 0&#125; stu.lean() // Student lean var stu2 Student = Student&#123;&quot;Jason&quot;, 22&#125; fmt.Println(stu2) //&#123;Jason 22&#125; stu2.eat(&quot;Apple&quot;) //Jason eat Apple &amp;&#123;Jason 22&#125;&#125; 我们看到上面Student中的name和age字段都是非导出字段.那么如果我们要在不同的包中对其的值进行修改怎么办呢?这个时候我们就可以写上跟Java中setter和getter方法.如下123456func (stu *Student) setName(name string) &#123; stu.name = name&#125;func (stu *Student) getName() string &#123; return stu.name&#125; 一个Golang初学者,记录的东西难免有错误,还望多多指出啊.谢谢.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu下搭建Golang开发环境]]></title>
      <url>%2F2017%2F03%2Flets-go-env%2F</url>
      <content type="text"><![CDATA[一个android程序猿的Go之旅! ##Ubuntu开发环境下 下载地址 之后进入到下载目录后运行如下命令解压下载的go开发包到 /usr/local。官方推荐的目录。1tar -C /usr/local -xzf go1.8.linux-amd64.tar.gz 配置变量打开/etc/profile或者$HOME/.profile文件，加入如下内容1export PATH=$PATH:/usr/local/go/bin 自定义安装目录时：GoROOT为自定义的安装目录12export GOROOT=$HOME/go1.Xexport PATH=$PATH:$GOROOT/bin 打开终端，运行go env看有没有输出环境信息。有则配置成功 安装sublime进入官网下载ctrl+` 输入如下内容安装Package Control1import urllib.request,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib.request.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) Sublime安装sublime输入中文 安装GoSublime插件安装完GoSublime之后可能会报错：1MarGo: Missing required environment variables: GOPATH 这是因为配置的问题。打开GoSublime的配置文件。输入上面配置的信息1234567&#123; &quot;env&quot;: &#123; &quot;GOPATH&quot;: &quot;$HOME/golang&quot;, &quot;GOROOT&quot;: &quot;GOROOT=$HOME/go1.X&quot; &#125;&#125; 测试12345678package mainimport &quot;fmt&quot;import &quot;runtime&quot;func main() &#123; fmt.Printf(&quot;format %s&quot;, runtime.Version())&#125; 使用Sublime按Ctrl+B运行下程序看下输出。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava 过滤操作符]]></title>
      <url>%2F2017%2F02%2Frxjava-fliter-operator%2F</url>
      <content type="text"><![CDATA[#过滤操作我觉得对于过滤操作看下面这个图就够了。之后就是熟悉使用多敲敲吧。详细看着里 filter( ) — 过滤数据take 只发射前面的N项数据 filterFilter操作符使用你指定的一个谓词函数测试数据项，只有通过测试的数据才会被发射。filter( ) — 过滤数据 123456789101112Observable.just(1,2,3,4,5,6,7,7,8,2) .filter(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer integer) &#123; return integer%2 ==0; &#125; &#125;).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.i(TAG, "call: "+integer); &#125; &#125;); ##ofType 1234567891011//ofType//ofType是filter操作符的一个特殊形式。它过滤一个Observable只返回指定类型的数据。//ofType默认不在任何特定的调度器上指定。Observable.just(1,"Arya Stark",3,"jon snow",5,"Tyrion",7) .ofType(String.class) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, "call: "+s); &#125; &#125;); taketake 只发射前面的N项数据 123456789String[] strs = &#123;"Arya Stark","jon snow","Tyrion"&#125;; Observable.from(strs) .take(2) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, "call: "+s); &#125; &#125;); takelasttakelast发射Observable发射的最后N项数据 123456789String[] strs = &#123;"Arya Stark","jon snow","Tyrion"&#125;; Observable.from(strs) .takeLast(2) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, "call: "+s); &#125; &#125;); ##lastlast只发射最后一项（或者满足某个条件的最后一项）数据12345678String[] strs = &#123;"Arya Stark","jon snow","Tyrion"&#125;; Observable.from(strs).last() .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, "call: "+s); &#125; &#125;); ##skipskip抑制Observable发射的前N项数据12345678Observable.just(1,2,3,4,5,6) .skip(2) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.i(TAG, "call: "+integer); &#125; &#125;); ##skiplastskiplast//抑制Observable发射的后N项数据 12345678Observable.just(1,2,3,4,5,6) .skipLast(2) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.i(TAG, "call: "+integer); &#125; &#125;); ##distinctdistinct抑制（过滤掉）重复的数据项 12345678Observable.just(1,2,3,5,2,2,3) .distinct() .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.i(TAG, "call: "+integer); &#125; &#125;); ##debouncedebounce仅在过了一段指定的时间还没发射数据时才发射一个数据 12345678Observable.just(1,2,3,4,5,6,7,8,9) .debounce(2,TimeUnit.SECONDS) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.i(TAG, "call: "+integer); &#125; &#125;); ##elementAtelementat只发射第N项数据RxJava将这个操作符实现为elementAt，给它传递一个基于0的索引值，它会发射原始Observable数据序列对应索引位置的值，如果你传递给elementAt的值为5，那么它会发射第六项的数据。 12345678Observable.just(1,2,3,4) .elementAt(2) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.i(TAG, "call: "+integer); &#125; &#125;); //输出3 ##samplesample定期发射Observable最近发射的数据项 12345678Observable.interval(1,TimeUnit.SECONDS) .sample(5,TimeUnit.SECONDS) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.i(TAG, "call: "+aLong); &#125; &#125;); ##ignoreElements不发射任何数据，只发射Observable的终止通知]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava 变换操作符]]></title>
      <url>%2F2017%2F02%2Frxjava-transform-operator%2F</url>
      <content type="text"><![CDATA[变换操作摘抄自Reactive X文档中文翻译 map 对序列的每一项都应用一个函数来变换Observable发射的数据序列 flatmap 将Observable发射的数据集合变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observablejavajavajavajavajavajavascan 对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值 groupBy 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据 [buffer][5 ?window 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项 mapmap 对序列的每一项都应用一个函数来变换Observable发射的数据序列 1234567891011121314//比如将每个字符串拼接上 \n from magicer String[] str = &#123;"winter is coming","the king in the north"&#125;; Observable.from(str).map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s+"\n from magicer"; &#125; &#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, "call: "+s); &#125; &#125;); &#125; flatmapflatmap 将Observable发射的数据集合变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable 123456789101112//这里的nickName是个List&lt;String&gt; Observable.from(mStudents).flatMap(new Func1&lt;Student, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(Student student) &#123; return Observable.from(student.getNickNames()); &#125; &#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, "call: "+s); &#125; &#125;); scanscan 对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值 1234567891011Observable.just(1,2,3,4,5).scan(new Func2&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer, Integer integer2) &#123; return integer+integer2; &#125; &#125;).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.i(TAG, "call: "+integer); &#125; &#125;); groupbygroupBy 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据 12345678910111213141516Observable.interval(1, TimeUnit.SECONDS).groupBy(new Func1&lt;Long, Long&gt;() &#123; @Override public Long call(Long aLong) &#123; return aLong %2; &#125; &#125;).subscribe(new Action1&lt;GroupedObservable&lt;Long, Long&gt;&gt;() &#123; @Override public void call(final GroupedObservable&lt;Long, Long&gt; result) &#123; result.subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.i(TAG, "groupby call: "+aLong+" getKey:"+result.getKey()); &#125; &#125;); &#125; &#125;); bufferbuffer 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个 12345678Observable.interval(1,TimeUnit.SECONDS) .buffer(3,TimeUnit.SECONDS) .subscribe(new Action1&lt;List&lt;Long&gt;&gt;() &#123; @Override public void call(List&lt;Long&gt; longs) &#123; Log.i(TAG, "call: "+longs); &#125; &#125;); windowwindow 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项Window和Buffer类似，但不是发射来自原始Observable的数据包，它发射的是Observables，这些Observables中的每一个都发射原始Observable数据的一个子集，最后发射一个onCompleted通知。 12345678910111213Observable.interval(1,TimeUnit.SECONDS) .window(3,TimeUnit.SECONDS) .subscribe(new Action1&lt;Observable&lt;Long&gt;&gt;() &#123; @Override public void call(final Observable&lt;Long&gt; longObservable) &#123; longObservable.subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.i(TAG, "call: "+aLong); &#125; &#125;); &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava Creat操作符]]></title>
      <url>%2F2017%2F02%2Frxjava-create-operator%2F</url>
      <content type="text"><![CDATA[RxJava是 ReactiveX 在JVM上的一个实现，ReactiveX使用Observable序列组合异步和基于事件的程序。 教程抛物线大神的RxJava教程 依赖12compile &apos;io.reactivex:rxjava:1.0.14&apos;compile &apos;io.reactivex:rxandroid:1.0.1&apos; 创建操作符createCreate操作文档 摘要: 你可以使用Create操作符从头开始创建一个Observable，给这个操作符传递一个接受观察者作为参数的函数，编写这个函数让它的行为表现为一个Observable–恰当的调用观察者的onNext，onError和onCompleted方法。 最常用最基础的创建Observable对象的方法12345678910111213Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("hello"); subscriber.onNext("rxjava"); subscriber.onCompleted(); &#125; &#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, "call: "+s); &#125; &#125;); fromfrom文档摘要: 在RxJava中，from操作符可以转换Future、Iterable和数组。对于Iterable和数组，产生的Observable会发射Iterable或数组的每一项数据。123456789101112131415161718192021String[] strs = &#123;"hello","world","!"&#125;; //将一个Iterable, 一个Future, 或者一个数组转换成一个Observable //from默认不在任何特定的调度器上执行。然而你可以将Scheduler // 作为可选的第二个参数传递给Observable，它会在那个调度器上管理这个Future Observable.from(strs) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, "call: " + s); &#125; &#125;, new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; Log.i(TAG, "call: " + throwable.toString()); &#125; &#125;, new Action0() &#123; @Override public void call() &#123; Log.i(TAG, "call: complete"); &#125; &#125;); justjust文档摘要: Just将单个数据转换为发射那个数据的Observable。Just类似于From，但是From会将数组或Iterable的数据取出然后逐个发射，而Just只是简单的原样发射，将数组或Iterable当做单个数据123456Observable.just(1,2,3,4).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.i(TAG, "call: "+integer); &#125; &#125;); rangerange文档 摘要: Range操作符发射一个范围内的有序整数序列，你可以指定范围的起始和长度。 RxJava将这个操作符实现为range函数，它接受两个参数，一个是范围的起始值，一个是范围的数据的数目。如果你将第二个参数设为0，将导致Observable不发射任何数据（如果设置为负数，会抛异常）。 range默认不在任何特定的调度器上执行。有一个变体可以通过可选参数指定Scheduler。 123456Observable.range(3,4).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.i(TAG, "call: "+integer); // 3,4,5,6 &#125; &#125;); 从3开始发送4个Integer timertimer文档创建一个Observable，它在一个给定的延迟后发射一个特殊的值。123456Observable.timer(1, TimeUnit.SECONDS).subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.i(TAG, "call: "+aLong); //延时1秒执行 &#125; &#125;); 创建延时任务，每1秒后发射一次。 intervalinterval文档创建一个按固定时间间隔发射整数序列的Observable123456Observable.interval(1, TimeUnit.SECONDS).subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; Log.i(TAG, "call: "+aLong);//0，1,2,3,4,5...... &#125; &#125;); 每隔一秒发送一个Integer数据。 repeatrepeat文档创建一个发射特定数据重复多次的ObservableRxJava将这个操作符实现为repeat方法。它不是创建一个Observable，而是重复发射原始Observable的数据序列，这个序列或者是无限的，或者通过repeat(n)指定重复次数。 repeat操作符默认在trampoline调度器上执行。有一个变体可以通过可选参数指定Scheduler。123456Observable.just(2,3).repeat(2).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer integer) &#123; Log.i(TAG, "call: "+integer); &#125; &#125;); 重复发射两次Observable对象]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Retrofit 2.0的基本使用]]></title>
      <url>%2F2017%2F01%2Fandroid-retrofit2-basic%2F</url>
      <content type="text"><![CDATA[简介Retrofit是square公司全家桶中的一员。在okhttp基础上封装的一个网络请求框架。其他废话就不多说了。有几篇不错的文章，可以看一下。官方介绍深入浅出 Retrofit，这么牛逼的框架你们还不来看看？Retrofit2.0 集成1compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos; 使用我们需要为接口地址定义一个接口，如下。当接口为：http://192.168.0.78:8080/login时，我们可以把接口定义为这样。12345public interface LoginApi &#123; @FormUrlEncoded @POST("/login") Call&lt;ResponseBody&gt; login(@Field("username")String username, @Field("password")String password);&#125; 在我们想要做网络请求的时候，这样写：1234567891011121314151617Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://192.168.0.78:8080") .build();LoginApi login = retrofit.create(LoginApi.class);retrofit2.Call&lt;ResponseBody&gt; data = login.login(username, password);data.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(retrofit2.Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; if (response.isSuccessful()) &#123; &#125; else &#123; &#125; &#125; @Override public void onFailure(retrofit2.Call&lt;ResponseBody&gt; call, Throwable t) &#123; Log.i(TAG, "retrofit onFailure: " + t.getLocalizedMessage()); &#125;&#125;); 很明显。@POST表明该请求是POST请求。@Field是提交的表单数据。 各注解含义注解都是在定义接口的时候使用的。做网络请求的代码都是一样的。 @GET用来表明请求方式为GET请求。 @Path可以使用在POST和GET请求。例如：123456public interface AnswerApi &#123; @GET("/word/answer/&#123;barrier&#125;/&#123;stage&#125;/&#123;userId&#125;") Call&lt;ResponseBody&gt; answer(@Path("barrier")int barrier, @Path("stage")int stage, @Path("userId")String userId);&#125; @PathMap@Query可以使用在POST和GET请求。用来配置接口中的参数（?之后的）。 1234public interface QuestionsApi &#123; @GET("/word/questions") Call&lt;ResponseBody&gt; getQuections(@Query("wordIds") String wordIds, @Query("stage")int stage);&#125; @QueryMapsome看下这个就基本上没问题了。1234567891011121314151617181920212223//http://m2.qiushibaike.com/article/list/text?page=1//基本使用 @GET("/article/list/text?page=1") retrofit2.Call&lt;ResponseBody&gt; getData(); //动态替换参数，返回解析后的数据 @GET("/article/list/text?") Call&lt;Bean&gt; getGsonData(@Query("page") int page); // @GET("/article/list/text?") Call&lt;Bean&gt; getNetData(@QueryMap Map&lt;String,String &gt; map); @GET("/article/list/&#123;type&#125;?/") Call&lt;Bean&gt; getDataWithPath(@Path("type") String type,@Query("page") int page); @FormUrlEncoded //POST请求必须添加 @POST("/login?") Call&lt;ResponseBody&gt; postData(@Field("username") String username,@Field("pwd") String passwrod); @FormUrlEncoded @POST("/login?") Call&lt;ResponseBody&gt; postMapData(@FieldMap Map&lt;String,String&gt; map); @Body的使用如下所示，retrofit会把Bean转成json数据进行请求。默认使用的是Gson可以参考这里 链接 12@POST("/word/records")Call&lt;WordBrowseRecord&gt; postWordRecords(@Body Bean bean); ps：Gson怎么控制Date型数据的转换格式呢？看下面代码你就明白了12345678Gson gson = new GsonBuilder() .setDateFormat("yyyy-MM-dd HH:mm:ss") .create();Retrofit retrofit = new Retrofit.Builder() .baseUrl(Constants.HOST) .addConverterFactory(GsonConverterFactory.create(gson)) .build(); 自定义Client在一些情况下我们需要自定义clien，来设置一些请求的参数。那么怎么设置呢？ 直接上代码。 123456789101112131415161718192021222324 Interceptor interceptor = new Interceptor() &#123; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; Request request = chain.request() .newBuilder() .addHeader("Content-Type", "application/json") .addHeader("Accept-Encoding", "gzip, deflate") .addHeader("Connection", "keep-alive") .addHeader("Accept", "*/*") .addHeader("Cookie", "JSESSIONID") .build(); return chain.proceed(request); &#125; &#125;; OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(interceptor) .build(); //之后在使用的时候Retrofit retrofit = new Retrofit.Builder() .baseUrl(Constants.HOST) .addConverterFactory(GsonConverterFactory.create()) .client(client) .build();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[EventBus3.0的使用]]></title>
      <url>%2F2017%2F01%2Fandroid-eventbus3-basic%2F</url>
      <content type="text"><![CDATA[原文地址http://blog.magicer.xyz/2017/01/android-eventbus3-basic/ 简介EventBus是http://greenrobot.org/出的一个发布者/订阅者（Publisher/Subscriber）的事件总线。主要是用来在Android各个组件之间进行消息传递的。能够很好地对发布者和订阅者之间进行解耦。下图是官方给出的一个示意图： 集成 在项目的build.gradle文件中添加如下依赖：1compile &apos;org.greenrobot:eventbus:3.0.0&apos; 使用发布者Publisher 我们使用EventBus发布消息的时候很方便，只需要一句话就可以。如下：1EventBus.getDefault().post("hello"); 在这里我们发布的可以是基本数据类型，可以是字符串，也可以是对象。 订阅者Subscriber 当我们需要在一个Activity或者Fragment中订阅事件时。我们需要注册EventBus1EventBus.getDefault().register(this); 当我们注册了EventBus之后我们就需要取消注册。一般在Activity或Fragment销毁的时候注销。注销的代码如下：1EventBus.getDefault().unregister(this); @Subscriber 当我们注册了EventBus之后。我们就需要写一个方法。来对事件进行处理。如下：1234@Subscribepublic void test(String strging)&#123; Log.i("temp","printf "+string);&#125; 在这里。EventBus没有对函数的命进行规定。只需要加上注解@Subscribe，方法为public void即可。只要方法的参数跟post时的类型一致即可接受到改事件。 实例 比如说现在我们有个需求是。点击一个按钮就退出应用程序。那么我们使用EventBus可以怎么实现呢？首先。我们可以在BaseActivity中注册退出应用程序的时间，让其他的Activity都集成该类。123456789101112131415161718public class BaseActvity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); EventBus.getDefault().register(this); &#125; @Subscribe public void exitApp(ExitApp exitApp)&#123; finish(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); &#125;&#125; 这时候我们只需要在按钮的点击时间中发送改消息即可了。1EventBus.getDefault().post(new ExistApp()); 事件类ExistApp可以随意，这里只是用来表明语义。 @Subscribe(threadMode = xxx)在上面的例子中，我们并没有制定@Subscriber函数的线程。此时默认为：ThreadMode.POSTINGThreadMode是一个枚举类型。它的值有： POSTING, MAIN, BACKGROUND, ASYNC.源码中的注释写的很详细，见参考中ThreadMode的代码。简单的说就是。 POSTING: Subscriber在发布消息（调用post函数的线程）的线程中执行。 MAIN: Subscriber将在Android主线程中执行。 BACKGROUND: Subscriber在后台线程中执行 ASYNC: Subscriber在异步线程，也就是在独立的线程中执行。 优先级我们可以通过@Subscribe(priority = 100)指定一个Subscriber函数的优先级.默认的优先级是0。高优先级的Subscriber将会优先订阅事件。1234@Subscribe(priority = 100) public void onEvent(String string)&#123; Log.i("subscriber","subscriber "+string); &#125; 取消事件分发 在某些情况下，我们不想让事件被继续分发了。那么我们就可以在onEvent(这里的onEvent名称任意)中取消事件：12345@Subscribe(threadMode = ThreadMode.MAIN)public void onEvent(String string)&#123; Log.i("subscriber","subscriber "+string); EventBus.getDefault().cancelEventDelivery(exitApp);&#125; ProGuard这里参考官方文档中的代码：点我进入官方文档ProGuard部分12345678910-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125; # Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125; Android Studio插件在这里我推荐个Android Studio的插件：EventBus Intellij Plugin。该插件会在代码的左侧显示一个Android机器人的图标，点击该图标能够列出所有的Subscriber事件和Publisher 参考官方文档源码地址：GithubEventBus JavaDoc 12345678910111213141516171819202122232425262728293031323334353637383940/** * Each event handler method has a thread mode, which determines in which thread the method is to be called by EventBus. * EventBus takes care of threading independently from the posting thread. * * @see EventBus#register(Object) * @author Markus */public enum ThreadMode &#123; /** * Subscriber will be called in the same thread, which is posting the event. This is the default. Event delivery * implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for * simple tasks that are known to complete is a very short time without requiring the main thread. Event handlers * using this mode must return quickly to avoid blocking the posting thread, which may be the main thread. */ POSTING, /** * Subscriber will be called in Android's main thread (sometimes referred to as UI thread). If the posting thread is * the main thread, event handler methods will be called directly. Event handlers using this mode must return * quickly to avoid blocking the main thread. */ MAIN, /** * Subscriber will be called in a background thread. If posting thread is not the main thread, event handler methods * will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single * background thread, that will deliver all its events sequentially. Event handlers using this mode should try to * return quickly to avoid blocking the background thread. */ BACKGROUND, /** * Event handler methods are called in a separate thread. This is always independent from the posting thread and the * main thread. Posting events never wait for event handler methods using this mode. Event handler methods should * use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number * of long running asynchronous handler methods at the same time to limit the number of concurrent threads. EventBus * uses a thread pool to efficiently reuse threads from completed asynchronous event handler notifications. */ ASYNC&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 6.0之后的动态权限]]></title>
      <url>%2F2017%2F01%2Fandroid-api-23-permission%2F</url>
      <content type="text"><![CDATA[原文地址:http://blog.magicer.xyz/2017/01/android-api-23-permission/ 前言 在Android 6.0之前，开发Android应用程序的时，开发者需要使用什么权限只需要在AndroidManifest.xml文件中显示的声明即可。如下：123&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; 但是，在Android 6.0之后，Android对应用程序的权限进行了进一步的规范。分出来危险权限和一般权限，当我们需要危险权限的时候需要在运行时进行授权。这样做也有好处。对于一些应用用户的选择更多了。 权限分类官方权限教程当我们需要用到危险权限时，我们就需要动态的申请权限，那么危险权限有哪些呢？ 危险权限 一般权限对于常规的权限我们只需要在清单文件中注册即可，比如网络权限。 动态注册权限如果您的应用需要危险权限，则每次执行需要这一权限的操作时您都必须检查自己是否具有该权限。用户始终可以自由调用此权限，因此，即使应用昨天使用了相机，它不能假设自己今天仍具有该权限。 要检查您是否具有某项权限，请调用ContextCompat.checkSelfPermission() 方法。例如，以下代码段显示了如何检查 Activity 是否具有在日历中进行写入的权限： 123// Assume thisActivity is the current activityint permissionCheck = ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.WRITE_CALENDAR); 如果应用具有此权限，方法将返回 PackageManager.PERMISSION_GRANTED，并且应用可以继续操作。如果应用不具有此权限，方法将返回 PERMISSION_DENIED，且应用必须明确向用户要求权限。 以上是官方文档中关于检测权限的说明。先来个小demo。看下怎么动态的请求权限，也可以看官方文档中的介绍。123456789101112131415161718192021222324252627282930313233343536373839404142private static final int PERMISSION_REQUEST_CODE = 1; //权限请求码@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (checkPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; //获取权限后的操作。读取文件 &#125;else &#123; //请求权限 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, PERMISSION_REQUEST_CODE); &#125;&#125;/** * 检测权限是否授权 * @return */private boolean checkPermission(Context context, String permission) &#123; return PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(context,permission);&#125;@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode)&#123; case PERMISSION_REQUEST_CODE: if (grantResults.length &gt;0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; //得到了授权 Toast.makeText(this, "授权成功", Toast.LENGTH_SHORT).show(); &#125;else &#123; //未授权 Toast.makeText(this, "授权失败", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125; 当用户点击了禁止按钮后，当我们下次还需要该权限怎么办？ shouldShowRequestPermissionRationale()函数会在用户点击了禁止后返回true，我们可以在该方法返回true时在提示用户开启权限。代码跟上面的差不多。可以简要看一下。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 private static final int PERMISSION_REQUEST_CODE = 1; //权限请求码 private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mButton = (Button) findViewById(R.id.activity_main_storage_btn); mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; storagePermission(); &#125; &#125;); &#125; private void storagePermission() &#123; if (checkPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; //获取权限后的操作。读取文件 &#125;else &#123;// //请求权限// ActivityCompat.requestPermissions(this,// new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,// PERMISSION_REQUEST_CODE); if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)) &#123; Toast.makeText(this, "需要开启存储权限", Toast.LENGTH_SHORT).show(); showRequestPermissionDialog(new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,PERMISSION_REQUEST_CODE); &#125;else &#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, PERMISSION_REQUEST_CODE); &#125; &#125; &#125; private void showRequestPermissionDialog(final String[] permissions, final int requestCode) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setMessage("使用该功能需要使用SD卡权限\n是否再次开启权限"); builder.setPositiveButton("是", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCompat.requestPermissions(MainActivity.this,permissions,requestCode); &#125; &#125;); builder.setNegativeButton("否",null); builder.setCancelable(true); builder.show(); &#125; /** * 检测权限是否授权 * @return */ private boolean checkPermission(Context context, String permission) &#123; return PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(context,permission); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode)&#123; case PERMISSION_REQUEST_CODE: if (grantResults.length &gt;0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; //得到了授权 Toast.makeText(this, "授权成功", Toast.LENGTH_SHORT).show(); &#125;else &#123; //未授权 Toast.makeText(this, "授权失败", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用SpannableStringBuilder打造超炫酷的TextView]]></title>
      <url>%2F2016%2F12%2Fandroid-SpannableStringBuilder-textview-rich-text%2F</url>
      <content type="text"><![CDATA[原文地址:http://blog.magicer.xyz/2016/12/android-SpannableStringBuilder-textview-rich-text/ 前段时间项目中使用到了一种效果是更改textview中制定字符串的颜色.于是就查找了下资料,发现了使用SpannableStringBuilder可以很轻易的就实现,并不用使用自定义View.那么就直接先来个代码练练手,运行看下效果. 12345String content = "NO ZUO NO DIE!";SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder(content);ForegroundColorSpan colorSpan = new ForegroundColorSpan(Color.parseColor("#009688"));spannableStringBuilder.setSpan(colorSpan,3,6, Spanned.SPAN_EXCLUSIVE_INCLUSIVE);mTextView.setText(spannableStringBuilder); 运行完了之后肯定会有些疑惑,最主要的SpannableStringBuilder是什么鬼? ForegroundColorSpan又是什么? Spanned.SPAN_EXCLUSIVE_INCLUSIVE 是什么意思? 那么我们来一个一个的解释. 1234void setSpan (Object what, //设置的样式,看完下面的就明白了. int start, //开始的位置. 索引是从0开始的. int end, //样式结束的位置,不包括end int flags) // 样式的标志. 下面详细介绍 flags: Spannable.SPAN_EXCLUSIVE_INCLUSIVE : 在 Span前面输入的字符不应用 Span的效果，在后面输入的字符应用Span效果。 Spannable.SPAN_INCLUSIVE_EXCLUSIVE: 在 Span前面输入的字符应用 Span 的效果，在后面输入的字符不应用Span效果。 Spanned.SPAN_INCLUSIVE_INCLUSIVE: 前后都包括 Spanned.SPAN_EXCLUSIVE_EXCLUSIVE: 前后都不包括 SpannableStringBuilder是什么鬼? 官方文档是这样写的. This is the class for text whose content and markup can both be changed.很简单,主要作用就是给文本内容添加样式的.主要通过setSpan方法设置样式.就像上面程序中那样. setSpan方法的三个参数是什么意思呢 ForegroundColorSpan 是什么? 根据它的意思就可以猜到,他是用来改变前景色的(也就是文本颜色).有文本颜色那是不是也有背景颜色等其他的呢?那是肯定的啦.只改变个文本颜色岂不是太low了呀. 那么都是主要的都是有哪些呢? 这个类里面的之类都是可以的. 点我查看,无需翻墙这些类跟ForegroundColorSpan都是大同小异的.掌握了一个,其他的也就掌握了.我认为常用的是ImageSpan,ClickableSpan,ForegroundColorSpan 再来几个代码练练 再来个ImageSpan跟ForegroundColorSpan混合的的看下效果. 1234567String content = "NO ZUO NO DIE!";SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder(content);ForegroundColorSpan colorSpan = new ForegroundColorSpan(Color.parseColor("#009688"));spannableStringBuilder.setSpan(colorSpan,3,6, Spanned.SPAN_INCLUSIVE_INCLUSIVE);ImageSpan imageSpan = new ImageSpan(this,R.mipmap.ic_launcher);spannableStringBuilder.setSpan(imageSpan,2,3,Spanned.SPAN_EXCLUSIVE_INCLUSIVE);mTextView.setText(spannableStringBuilder); 最后来张效果图:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android基础知识之 Toolbar 的使用]]></title>
      <url>%2F2016%2F10%2Ftoolbar-basic%2F</url>
      <content type="text"><![CDATA[原文地址:http://blog.magicer.xyz/2016/10/toolbar-basic/ Toolbar是Android5.0推出的,用来替代ActionBar的控件.可以高度的自定义,使用灵活.官方的ToolBar是必须在5.0以上的系统才能使用, 如果需要在低版本中使用.需要使用support v7包中的Toolbar.下一是官网的Toolbar的介绍:123456Toolbarextends ViewGroupjava.lang.Object ↳ android.view.View ↳ android.view.ViewGroup ↳ android.support.v7.widget.Toolbar 使用前提 要使用ToolBar需要将activity的ActionBar隐藏掉.那么如何隐藏呢?有三种方法.下面分别介绍 方法一: 在res/values/styles.xml文件中修改 1234 &lt;style name="AppTheme.Base" parent="Theme.AppCompat"&gt; &lt;item name="windowActionBar"&gt;false&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt; 也可以直接使用没有ActionBar的主题 1&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; 方法二:在清单文件中修改制定activity的主题,如下所示: 123&lt;activity android:name="MainActivity" android:theme="@style/Theme.AppCompat.Light.NoActionBar"&gt;&lt;/activity&gt; 方法三: 直接在代码中取消. 在setContentView之前. 123requestWindowFeature(Window.FEATURE_NO_TITLE);setContentView(R.layout.activity_main);//supportRequestWindowFeature(Window.FEATURE_NO_TITLE); 在AppCompatActivity中 怎么使用 在布局文件中.添加如下代码. 位置不固定.123456789&lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?android:attr/actionBarSize" android:background="?attr/colorPrimaryDark" app:title="Title" app:titleTextColor="#222222" app:logo="@mipmap/ic_launcher" app:subtitle="subtitle"&gt;&lt;/android.support.v7.widget.Toolbar&gt; title 用来设置标题.subtitle设置副标题 titleTextColor用来设置标题字体颜色.background用来设置背景颜色..效果如下: 在java代码中也可以动态的设置这些值. 1234567 mToolbar.setTitle("JavaTitle"); mToolbar.setSubtitle("JavaSubTitle"); mToolbar.setLogo(R.mipmap.ic_launcher); mToolbar.setNavigationIcon(android.R.drawable.ic_input_delete); mToolbar.setOverflowIcon(ContextCompat.getDrawable(this, android.R.drawable.ic_menu_more));// setActionBar(mToolbar); //activity中 setSupportActionBar(mToolbar); //AppCompatActivity中 添加Menu要添加menu首先我们需要有menu,在这里我选择在res/menu/中创建main.xml来定义menu文件.代码如下 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/add" android:icon="@android:drawable/ic_menu_add" android:title="Add" app:showAsAction="never|withText"/&gt; &lt;item android:id="@+id/delete" android:icon="@android:drawable/ic_menu_delete" android:title="Delete" app:showAsAction="never|withText"/&gt; &lt;item android:id="@+id/edit" android:icon="@android:drawable/ic_menu_edit" android:title="Edit" app:showAsAction="never|withText"/&gt; &lt;item android:id="@+id/email" android:icon="@android:drawable/sym_action_email" android:title="Email" app:showAsAction="never|withText"/&gt;&lt;/menu&gt; 下面是java文件中的代码.123456789101112131415161718192021222324252627@Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: Toast.makeText(MainActivity.this, "您点击了NavigationIcon", Toast.LENGTH_SHORT).show(); break; case R.id.add: Toast.makeText(MainActivity.this, "Add", Toast.LENGTH_SHORT).show(); break; case R.id.delete: Toast.makeText(MainActivity.this, "Delete", Toast.LENGTH_SHORT).show(); break; case R.id.edit: Toast.makeText(MainActivity.this, "Edit", Toast.LENGTH_SHORT).show(); break; case R.id.email: Toast.makeText(MainActivity.this, "Email", Toast.LENGTH_SHORT).show(); break; &#125; return true; &#125; 显示Menu中的Icon在写到这里之后.我们会发现.隐藏的menu是不显示icon的,那么我们怎么设置呢:只需要重新一下方法: 这里的activity是 AppCompatActivity 12345678910111213141516171819@Overrideprotected boolean onPrepareOptionsPanel(View view, Menu menu) &#123; if (menu != null) &#123; if (menu.getClass() == MenuBuilder.class) &#123; try &#123; Method m = menu.getClass().getDeclaredMethod("setOptionalIconsVisible", Boolean.TYPE); m.setAccessible(true); m.invoke(menu, true); &#125; catch (Exception e) &#123; Log.i("tag", "onPrepareOptionsPanel: " + getClass().getSimpleName() + "onMenuOpened...unable to set icons for overflow menu" + e); &#125; &#125; &#125; return super.onPrepareOptionsPanel(view, menu);&#125; 效果如下:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ViewPager PagerAdapter的简单使用]]></title>
      <url>%2F2016%2F09%2Fviewpager-pageradapter%2F</url>
      <content type="text"><![CDATA[以下是官方文档中对ViewPager的说明 Layout manager that allows the user to flip left and right through pages of data. You supply an implementation of a PagerAdapter to generate the pages that the view shows. ViewPager是android.support-v4包下的一个组件。用来实现左右滑动的效果。和TabLayout的联动使用的效果挺不错。那么ViewPager的基本使用，是怎样的呢。 呢？和其他的组件一样。我们只需要在布局中添加即可。 12345&lt;android.support.v4.view.ViewPager android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/viewpager" /&gt; 在这里我们需要一个PagerAdapter来对ViewPager进行填充。首先我们需要一个数据源，在这里我们用一个List&lt;ImageView&gt;。当创建PagerAdapter的时候，我们需要实现四个方法：getCount, isViewFromObject, instantiateItem, destroyItem。最基础的应用的代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyAdapter extends PagerAdapter &#123; private List&lt;ImageView&gt; mList; public MyAdapter(List&lt;ImageView&gt; list) &#123; mList = list; &#125; @Override public int getCount() &#123; return mList.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return view == object; &#125; /** * 实例化页面 * @param container * @param position * @return */ @Override public Object instantiateItem(ViewGroup container, int position) &#123; container.addView(mList.get(position)); return mList.get(position); &#125; /** * 删除页面 * @param container * @param position * @param object */ @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView(mList.get(position)); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用FragmentPagerAdapter和FragmentStatePagerAdapter时Fragment生命周期区别]]></title>
      <url>%2F2016%2F09%2Ffragmentpageradapter-and-fragmentstatepageradapter%2F</url>
      <content type="text"><![CDATA[使用FragmentPagerAdapter时Fragment的生命周期FragmentPagerAdapter 会保存在内存中保存Fragment的实例，当ViewPager中Fragment的数量较多时，建议使用FragmentStatePagerAdapter。 当使用FragmentPagerAdapter时Fragment的生命周期怎么走呢？（使用的是v4包下的Fragment） 当viewpager加载时，会加载当前页跟相邻页的fragment（如果有），那么此时，Fragment的log日志是这样的123456789101112I/fragment: onAttach: I/fragment: onCreate: I/fragment: onAttach: I/fragment: onCreate: I/fragment: onCreateView: +position 1I/fragment: onActivityCreated: +position 1I/fragment: onCreateView: +position 0I/fragment: onActivityCreated: +position 0I/fragment: onStart: 0I/fragment: onResume: 0I/fragment: onStart: 1I/fragment: onResume: 1 我们看到，有两个Fragment的生命周期都走了，而他们基本上算是交替执行的。那么当我们滑动到第三个页面再划回第一个页面呢？生命周期又会怎么走？肯定的第三个页面和第四个页面的onAttach，onCreate,onCreateView,onActivityCreate,onStart,onResume生命周期都会执行。那么顺序是怎么样的呢？我们来看下log日志。12345678910111213141516171819202122232425262728293031//以下是滑动到Fragment3时走的的生命周期I/fragment: onAttach: I/fragment: onCreate: I/fragment: onCreateView: +position 2I/fragment: onActivityCreated: 2I/fragment: onStart: 2I/fragment: onResume: 2I/fragment: onAttach: I/fragment: onCreate: I/fragment: onPause: 0I/fragment: onStop: 0I/fragment: onDestroyView: 0I/fragment: onCreateView: +position 3I/fragment: onActivityCreated: 3I/fragment: onStart: 3I/fragment: onResume: 3//以下是滑动到fragment0的I/fragment: onCreateView: +position 0I/fragment: onActivityCreated: 0I/fragment: onPause: 3I/fragment: onStop: 3I/fragment: onDestroyView: 3I/fragment: onStart: 0I/fragment: onResume: 0I/fragment: onPause: 2I/fragment: onStop: 2I/fragment: onDestroyView: 2 我们发现Fragment2的生命周期先走到了onResume，之后Fragment0走到了onDestoryView中，而当我们重新滑到Fragment0的时候，Fragment0的生命周期是从onCreateView开始走的，并没有走onCreate方法。 使用FragmentStatePagerAdapter时Fragment的生命周期当使用FragmentStatePagerAdapter时，第一次走的生命周期跟FragmentPagerAdapter是一样的。但是当我们滑动到第三个Fragment（即：Fragment 2）再划回第一个Fragment（Fragment 0）呢？生命周期如下：1234567891011121314151617181920212223242526272829303132333435363738I/fragment: onAttach: I/fragment: onCreate: I/fragment: onCreateView: +position 2I/fragment: onActivityCreated: 2I/fragment: onStart: 2I/fragment: onResume: 2I/fragment: onAttach: I/fragment: onCreate: I/fragment: onPause: 0I/fragment: onStop: 0I/fragment: onDestroyView: 0I/fragment: onDestroy: 0I/fragment: onDetach: 0I/fragment: onCreateView: +position 3I/fragment: onActivityCreated: 3I/fragment: onStart: 3I/fragment: onResume: 3I/fragment: onAttach: I/fragment: onCreate: I/fragment: onPause: 3I/fragment: onStop: 3I/fragment: onDestroyView: 3I/fragment: onDestroy: 3I/fragment: onDetach: 3I/fragment: onCreateView: +position 0I/fragment: onActivityCreated: 0I/fragment: onStart: 0I/fragment: onResume: 0I/fragment: onPause: 2I/fragment: onStop: 2I/fragment: onDestroyView: 2I/fragment: onDestroy: 2I/fragment: onDetach: 2 我们可以看到，当我们滑动到第三个Fragment（Fragment 2）时，第一个Fragment（Fragment 0）的生命周期已经走到了onDetach，此时Fragment0已经和activity解绑。也就不会在内存中保存Fragment的实例。 分析通过上面的Fragment的生命周期我们可以看到，当ViewPager使用FragmentPagerAdapter时滑动viewpager，Fragment并不会跟acvitity解绑，并且划回该Fragment时，onCreate方法也不会执行。FragmentStatePagerAdapter时，Fragment已经跟activity解绑了，重新划回该Fragment时，Fragment的生命周期会全部走一遍。 因此当我们在Fragment的onCreate方法中执行的网络请求，那么在FragmentPagerAdapter中，该网络请求只会执行一次，而FragmentStatePagerAdapter则会每次都得到执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试flow.ci]]></title>
      <url>%2F2016%2F08%2Ftext%2F</url>
      <content type="text"><![CDATA[测试flow.ci]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为Hexo NexT主题添加ShareSDK的分享]]></title>
      <url>%2F2016%2F04%2Fadd-sharesdk%2F</url>
      <content type="text"><![CDATA[今天发现一个分享的的sdk,可以在各个平台使用。由于不太喜欢主题提供的几个分享的样式。就试了试怎么这个。发现还是不错滴。。下面是分享的按钮和分享的样式：效果见下面—-传送门：ShareSDKWeb集成官方文档 下面是在网页上分享按钮的代码，只需要将以下代码添加到想要显示的位置即可。appkey是你自己的appkey。12345678910111213141516171819&lt;!--MOB SHARE BEGIN--&gt;&lt;div class="-mob-share-ui-button -mob-share-open"&gt;分享&lt;/div&gt;&lt;div class="-mob-share-ui" style="display: none"&gt; &lt;ul class="-mob-share-list"&gt; &lt;li class="-mob-share-weibo"&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-tencentweibo"&gt;&lt;p&gt;腾讯微博&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-qzone"&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-qq"&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-renren"&gt;&lt;p&gt;人人网&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-kaixin"&gt;&lt;p&gt;开心网&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-douban"&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-facebook"&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-twitter"&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="-mob-share-close"&gt;取消&lt;/div&gt;&lt;/div&gt;&lt;div class="-mob-share-ui-bg"&gt;&lt;/div&gt;&lt;script id="-mob-share" src="http://f1.webshare.mob.com/code/mob-share.js?appkey=你的appkey"&gt;&lt;/script&gt;&lt;!--MOB SHARE END--&gt; 添加到NexT中那么怎么添加到next主题上呢。步骤如下 1.创建文件我们首先要在主题文件夹下的layout文件夹找到_partials下的share文件夹，之后添加一个名为sharesdk.swig的文件。我们可以看出来。这个文件夹下放的全部是分享的配置文件.添加的内容为上面的那一大段代码。只需要修改一部分。修改的部分为：1&lt;script id=&quot;-mob-share&quot; src=&quot;http://f1.webshare.mob.com/code/mob-share.js?appkey=&#123;&#123; theme.shareSDKappkey &#125;&#125;&quot;&gt;&lt;/script&gt; 修改这写的目的是为了让我们能够在主题的配置文件中添加appkey。（只需要在主题的配置文件中添加一个shareSDKappkey并为其附上值即可）。 2添加可选配置虽然我们添加了sharesdk的分享的按钮了，但是如果有一天我们不想使用了呢。当然，很简单。只需要修改配置文件就可以了。那么如何实现呢？首先，找到主题文件夹下的layout文件夹下的post.swig大概在16行左右添加12345678910111213&lt;div class="post-spread"&gt; &#123;% if theme.jiathis %&#125; &#123;% include '_partials/share/jiathis.swig' %&#125; &#123;% elseif theme.baidushare %&#125; &#123;% include '_partials/share/baidushare.swig' %&#125; &#123;% elseif theme.add_this_id %&#125; &#123;% include '_partials/share/add-this.swig' %&#125; &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125; &#123;% include '_partials/share/duoshuo_share.swig' %&#125; &#123;% elseif theme.sharesdk %&#125; &#123;% include '_partials/share/sharesdk.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 添加了代码12&#123;% elseif theme.sharesdk %&#125; &#123;% include &apos;_partials/share/sharesdk.swig&apos; %&#125; 这段代码就是根据主题文件的配置，来为文档添加相应的swig文件。要想实现在配置文件中选择性的使用分享功能，只需要在配置文件中修改即可。 修改_config.yml接下来就是修改项目的配置文件了。在主题的配置文件中添加：123#Sharesharesdk: trueshareSDKappkey: appkey 如果想使用就可以设置为true并添加appkey了。当然不想使用。直接注释就可以了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[修改了host文件之后github无法记载样式表的解决方案]]></title>
      <url>%2F2016%2F04%2Fgithub-could-not-load-css%2F</url>
      <content type="text"><![CDATA[今天由于某种原因想要使用Google结果就修改了Host文件，结果发现，在登录Githu的时候无法加载样式表了。好悲催，好不容易Google可以使用了，不能把host文件在改回去吧，不能忍。于是，看了分析了一下github页面，发现： 复制上图中的地址 然后在ipaddress.com上找到该地址的IP。例如： 查找完之后，打开host文件添加 1185.31.17.133 assets-cdn.github.com 其他的资源无法加载，解决方法类似： 下面是我往host文件中添加的记录： 1234567891011 # Github start 192.30.252.141 gist.github.com# Github end#fix github cdn problem because of GFW#185.31.17.184 github.global.ssl.fastly.net23.235.40.133 assets-cdn.github.com185.31.17.133 avatars3.githubusercontent.com23.235.40.133 avatars1.githubusercontent.com185.31.17.133 avatars0.githubusercontent.com192.30.252.120 github.com185.31.17.133 avatars2.githubusercontent.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java插入排序，选择排序和冒泡排序的简单使用]]></title>
      <url>%2F2016%2F03%2Fbubble-selection-insert-sort-1%2F</url>
      <content type="text"><![CDATA[排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中的进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。 ##冒泡排序经过一次次的交换，最小的数慢慢的交换到数组开头，像冒泡泡。 专业描述： 前提条件：序列S={S0,S1,S2….Sn-1}是n个可排序元素的系列 1、令j从n-1递增到j，重复 2–4 2、令i从1递增到j，重复 3 3、如果元素Si-1个Si成反序 交换他们 4、结束标记，序列{S0………Sj}被排序，且Sj最大 算法步骤：1、比较相邻的元素，如果第一个大，就交换他们。2、对每一个相邻的元素都比较并交换，从开始到最后一对，每次都可以保证最后的那个元素是最大的。3、针对所有的元素，重复执行，除了最后一个（因为最后一个已经是最大的）。4、每次重复上面的步骤，知道没有任何一对数字需要比较12345678910111213141516171819202122232425public class BubbleSort &#123; public static void bubbleSort(int[]arr)&#123; int temp; for(int i=0;i&lt;arr.length-1;i++)&#123; //控制循环次数，最多length-1次 for(int j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; //交换，大的值交换到后面 temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; //打印出每次排序的数组； for(int num:arr)&#123; System.out.print(num+" "); &#125; System.out.println(); &#125; &#125; public static void main(String[] args) &#123; int[] arrays=&#123;12,14,65,21,23,3,45,4&#125;; bubbleSort(arrays); &#125;&#125; 伪代码如下：1234for i &lt;---1 to length[A] do for j &lt;---length[A] down to i+1 do if A[j] &lt; A[j-1] then exchange A[j] &lt;--&gt; A[j-1] 在网上找了个图示，如下： 插入排序插入排序的一个典型例子就是扑克牌，联想一下扑克牌我们就可以很好的理解插入排序是如何工作的。算法步骤：1、将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当作是未排序序列。2、从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素和有序序列中的某个元素相等，则将带插入元素插入到相等元素的后面） 12345678for j &lt;-- 2 to length[A] do key &lt;-- A[j] ##insert A[j] into the sorted sequence A[1......j-1] i &lt;--j-1 while i &gt;=0 and A[i] &gt; key do A[i+1] &lt;-- A[i] i &lt;-- i A[i+1] &lt;-- key 代码： 1234567891011public static void insert(int[] array)&#123; int i,j;int insertNode; for(i=1;i&lt;array.length;i++)&#123; insertNode = array[i]; j = i+1; while(j&gt;=0&amp;&amp;insertNode &lt; array[j])&#123; array[j+1] = array[j]; j--&#125; &#125;&#125; 选择排序 基本思想：直接选择排序的基本思想是：第i趟排序开始时，当前有序区和无序区分别为R[1····i-1]和R[i····n]（1&lt;=i&lt;=n）该趟排序则是从当前无序区选出关键字最小的记录 R[k] 将它与无序区的第一个记录R[i]交换，使R[1····i]和R[i+1···n]分别变为新的有序区和新的无序区。因为每趟排序均使有序区中增加了一个记录，且有序区中的记录关键字均不大于无序区中记录的关键字，即第i趟排序之后 R[1···i].keys&lt;=R[i+1···n].keys 所以进行n-1趟排序之后有R[1·····n-1].key,即经过n-1趟排序之后，整个文件R[1····n]递增有序。注意：第1趟排序开始时，无序区为R[1·····n]。 1234567891011121314151617public static void choose(int[] array)&#123; for(int i=0;i&lt;a.length;i++)&#123; int tmp = a[i]; int index = i; for(int j=i+1;j&lt;a.length;j++)&#123; if(tmp&gt;array[j])&#123; //比较值，取出值小的下标 tmp = array[j]; index = j; &#125; &#125; if(i!=index)&#123; //交换两个的值，当前最小值的坐标等于当前坐标时。 int k = array[i]; array[i] = array[index]; array[index] = k; &#125; &#125;&#125; 简洁说明 选择排序时依次固定一个下标,让每个下标中的数和它后面的所有的数进行比较; 代码如下: 1234567891011 int[] arr = &#123; 2, 23, 4, 543, 53, 23, 56 &#125;;for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = i+1; j &lt; arr.length ; j++) &#123; if (arr[i] &gt; arr[j]) &#123; swap(arr, i, j); &#125; &#125;&#125;for(int i:arr)&#123; System.out.print(i+",");&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java static关键字及静态代码块的使用]]></title>
      <url>%2F2016%2F03%2Fjava-static-keywords%2F</url>
      <content type="text"><![CDATA[在了解static之前 ，先来了解下this关键字。多少有点渊源；首先 this是什么意识呢？this指代当前的对象 用法如下： this关键字this指代当前对象 123456789101112 public class Cirlcle &#123;final static double PI=3.14;double radius;Point point;public Cirlcle()&#123; &#125;public Cirlcle(double radius,Point point)&#123; this.radius=radius; this.point=point;&#125; &#125; 在此程序中this指代当前对象，如果不加上this时，将无法达到预期的效果，因为形式参数radius的作用域只在方法里，当加上this时代表的是当前对象的radius，所以此时可以达到为对象的域赋值的作用。 this只能在方法内部使用，表示对”调用方法的那个对象“的引用，如果在方法内部调用同一个类的另一个方法则不用用this，直接调用即可。只有需要明确指出对当前对象的引用时，才需要使用this关键字。 this调用构造器还是那个程序： 1234567891011 public class Cirlcle &#123;final static double PI=3.14;double radius;Point point;public Cirlcle(double radius)&#123; this(radius,null);&#125;public Cirlcle(double radius,Point point)&#123; this.radius=radius; this.point=point;&#125; 在重载的一个参数的构造器中就调用了另一个构造器Cirlcle(double radius,Point point)，利用次构造器来在当前构造器中对域进行初始化工作。 但是此时要注意的是，this()必须放在方法的第一行。 this还有另外一个用法，即用在return语句上。 1234567891011121314151617181920 public class Book &#123; String name; double price; int id; public Book printPrice()&#123; price=100.0; System.out.println(&quot;Book price:&quot;+price); return this; //返回对当前对象的引用 &#125; public Book printName()&#123; name=&quot;Thinking in Java&quot;; System.out.println(&quot;Book name:&quot;+name); return this; //返回对当前对象的引用 &#125; public static void main(String[] args) &#123; Book book = new Book(); book.printName().printPrice(); &#125;&#125; 在方法中由于利用return返回了对当前对象的引用，所以可以使用.来执行多条语句 接下来，就要来讲解static的用法了。准备好了么？ static关键字static：静态； static域static域是所有对象所共有的，是属于类所有，而不是特定的对象。当对其进行我们还是用上面的程序，例如：书都是一个特定图书馆的，所以此时我们就可以定义一个static类型的域来表明所有的Book都是国家图书馆的。此时我们就可以这样定义： 123456789101112131415161718192021public class Book &#123; static String library=&quot;国家图书馆&quot;; //static域 String name; double price; int id; public Book printPrice()&#123; price=100.0; System.out.println(&quot;Book price:&quot;+price); return this; &#125; public Book printName()&#123; name=&quot;Thinking in Java&quot;; System.out.println(&quot;Book name:&quot;+name); return this; &#125; public static void main(String[] args) &#123; Book book = new Book(); book.printName().printPrice(); System.out.println(&quot;library:&quot;+Book.library); &#125;&#125; 当定义了static域之后我们就可以用 类名.域 来的到该值static域在内存中有一块特定的内存，每个对象所公用，当在一个对象中对其进行了修改，则其他对象的词域也会被修改。notes:构造器中不要有static域； static方法 利用static修饰的方法就是static方法；最典型的就是main() static字段对于每个对象都是公用的同一块内存区域。而static方法的一个最主要的用法是在没有创建对象的情况下调用方法。 static方法就是没有this的方法（也没有super），而且在static的内部不能调用非静态方法和非静态域； 在上面的代码中添加 1234public static void printInfo()&#123; System.out.println(name+price); //error 静态方法中不能调用非静态域 printName(); //error 静态方法中不能调用非静态方法&#125; static代码块 代码块是用{}括起来的部分；在方法中的是一般代码块，在类中声明的一般代码块就是构造代码块。而用static修饰的代码块就是静态代码块；当然还有同步代码块，现在就不做介绍了。 接下来我们来看个程序： 1234567891011121314public class Book &#123; &#123; System.out.println(&quot;构造代码块&quot;); &#125; static&#123; System.out.println(&quot;静态代码块&quot;); &#125; public static void main(String[] args) &#123; &#123; System.out.println(&quot;一般代码块&quot;); &#125; &#125;&#125; 此程序的运行结果为： 12静态代码块一般代码块 我们可以看到，最先执行的是静态代码块。而不是在main()方法中的一般代码块。静态代码块是最先执行的，以载入类就执行了。 再看下面的程序： 12345678910111213141516public class Book &#123; &#123; System.out.println(&quot;构造代码块&quot;); &#125; static&#123; System.out.println(&quot;静态代码块&quot;); &#125; public static void main(String[] args) &#123; &#123; System.out.println(&quot;一般代码块&quot;); &#125; new Book(); //添加了一行 new Book(); //添加了一行 &#125;&#125; 而此时的运行结果是： 1234静态代码块一般代码块构造代码块构造代码块 可以看到，构造代码块只有在创建对象的时候才会执行。 构造代码块跟构造器又是那个先执行的呢？来看下面的代码： 12345678910111213141516171819202122232425public class Book &#123; public Book()&#123; System.out.println(&quot;构造器&quot;); &#125; static&#123; System.out.println(&quot;静态代码块#####&quot;); &#125; &#123; System.out.println(&quot;构造代码块#####&quot;); &#125; &#123; System.out.println(&quot;构造代码块&quot;); &#125; static&#123; System.out.println(&quot;静态代码块&quot;); &#125; public static void main(String[] args) &#123; &#123; System.out.println(&quot;一般代码块&quot;); &#125; new Book(); new Book(); &#125;&#125; 运行结果是：123456789静态代码块#####静态代码块一般代码块构造代码块#####构造代码块构造器构造代码块#####构造代码块构造器 通过运行结果可以看到，最先执行的是静态代码块并且靠上的静态代码块先执行，然后是一般代码块,然后是构造代码块，靠上的先执行，然后才是构造器； 那么下面的顺序呢？运行结果是？ 12345new Book();new Book();&#123; System.out.println(&quot;一般代码块&quot;);&#125; 运行结果是：123456789静态代码块#####静态代码块构造代码块#####构造代码块构造器构造代码块#####构造代码块构造器一般代码块 显而易见了，先创建对象就先执行构造代码块构造器，然后是一般代码块，按顺序执行，谁靠上谁先执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Jsoup.jar的使用]]></title>
      <url>%2F2016%2F03%2FJava-Jsoup-jar-1%2F</url>
      <content type="text"><![CDATA[Jsoup的使用方法参见：http://www.open-open.com/jsoup/.上面是中文版的也有官方API。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * 通过网页来获取数据。 * */Document doc =Jsoup.connect("http://blog.magicer.xyz/").get();/* * 得到页面中 第一个class为“post-title”的内容，然后输出其的值 * */org.jsoup.nodes.Element string=doc.getElementsByClass("post-title").first(); System.out.println(string); /*输出结果为 &lt;h1 class="post-title" itemprop="name headline"&gt; &lt;a class="post-title-link" href="/2016/03/eclipse-import-jar/" itemprop="url"&gt; Eclipse如何导入外部jar包 &lt;/a&gt; &lt;/h1&gt; */ String title=string.text(); /* * 获得class名为post-title-link的属性的值 * (此处是一个a标签的href属性的值：/2016/03/eclipse-import-jar/) * */ String string2=doc.getElementsByClass("post-title-link").attr("href"); System.out.println(string2); //输出结果为：/2016/03/eclipse-import-jar/System.out.println(title); //输出结果是：Eclipse如何导入外部jar包 /* * 通过get()方法得到body的内容 get()方法的索引（index）从0 （即first（）方法）开始 * get(0)=first(); * */org.jsoup.nodes.Element postBodyString= doc.getElementsByClass("post-body").get(0);String postBody=postBodyString.text(); //得到post-body的内容System.out.println(postBody); // 可以正常的输出post-body的内容/* * 获得menu菜单项 * */org.jsoup.nodes.Element element=doc.getElementsByClass("menu").first();String menu= element.text();System.out.println(menu); // 输出结果为：首页 分类 归档 标签 关于 Elements这个对象提供了一系列类似于DOM的方法来查找元素，抽取并处理其中的数据。具体如下： 查找元素getElementById(String id)getElementsByTag(String tag)getElementsByClass(String className)getElementsByAttribute(String key) (and related methods)Element siblings: siblingElements(), firstElementSibling(), lastElementSibling();nextElementSibling(), previousElementSibling()Graph: parent(), children(), child(int index) ###元素数据attr(String key)获取属性attr(String key, String value)设置属性attributes()获取所有属性id(), className() and classNames()text()获取文本内容text(String value) 设置文本内容html()获取元素内HTMLhtml(String value)设置元素内的HTML内容outerHtml()获取元素外HTML内容data()获取数据内容（例如：script和style标签)tag() and tagName() ###操作HTML和文本append(String html), prepend(String html)appendText(String text), prependText(String text)appendElement(String tagName), prependElement(String tagName)html(String value) Selector选择器概述tagname: 通过标签查找元素，比如：ans|tag: 通过标签在命名空间查找元素，比如：可以用 fb|name 语法来查找 元素#id: 通过ID查找元素，比如：#logo.class: 通过class名称查找元素，比如：.masthead [^attr]: 利用属性名前缀来查找元素，比如：可以用[^data-] 来查找带有HTML5 Dataset属性的元素 [attr^=value], [attr$=value], [attr=value]: 利用匹配属性值开头、结尾或包含属性值来查找元素，比如：[href=/path/][attr~=regex]: 利用属性值匹配正则表达式来查找元素，比如： img[src~=(?i).(png|jpe?g)]: 这个符号将匹配所有元素Selector选择器组合使用el#id: 元素+ID，比如： div#logoel.class: 元素+class，比如： div.mastheadel[attr]: 元素+class，比如： a[href]任意组合，比如：a[href].highlightancestor child: 查找某个元素下子元素，比如：可以用.body p 查找在”body”元素下的所有p元素parent &gt; child: 查找某个父元素下的直接子元素，比如：可以用div.content &gt; p 查找 p 元素，也可以用body &gt; 查找body标签下所有直接子元素siblingA + siblingB: 查找在A元素之前第一个同级元素B，比如：div.head + divsiblingA ~ siblingX: 查找A元素之前的同级X元素，比如：h1 ~ pel, el, el:多个选择器组合，查找匹配任一选择器的唯一元素，例如：div.masthead, div.logo ###伪选择器selectors:lt(n): 查找哪些元素的同级索引值（它的位置在DOM树中是相对于它的父节点）小于n，比如：td:lt(3) 表示小于三列的元素:gt(n):查找哪些元素的同级索引值大于n，比如： div p:gt(2)表示哪些div中有包含2个以上的p元素:eq(n): 查找哪些元素的同级索引值与n相等，比如：form input:eq(1)表示包含一个input标签的Form元素:has(seletor): 查找匹配选择器包含元素的元素，比如：div:has(p)表示哪些div包含了p元素:not(selector): 查找与选择器不匹配的元素，比如： div:not(.logo) 表示不包含 class=”logo” 元素的所有 div 列表:contains(text): 查找包含给定文本的元素，搜索不区分大不写，比如： p:contains(jsoup):containsOwn(text): 查找直接包含给定文本的元素:matches(regex): 查找哪些元素的文本匹配指定的正则表达式，比如：div:matches((?i)login):matchesOwn(regex): 查找自身包含文本匹配指定正则表达式的元素注意：上述伪选择器索引是从0开始的，也就是说第一个元素索引值为0，第二个元素index为1等可以查看Selector API参考来了解更详细的内容]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Eclipse如何导入外部jar包]]></title>
      <url>%2F2016%2F03%2Feclipse-import-jar%2F</url>
      <content type="text"><![CDATA[今天需要往自己的项目中添加外部jar包，在这里记录下过程： 第一步 第一步当然是先下载jar文件 第二步 在项目内新建lib文件夹，把.jar文件copy进去； 第三步 在项目上右键 找到Build Path之后选择Configure Build Path,会出现： 点击Add JARs 找到jar文件 添加，之后点击确定。 之后就可以愉快的使用了。图片太少，以后再添加吧。就先记录到这些。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[eclipse使用过程中遇到的问题]]></title>
      <url>%2F2016%2F03%2Feclipse-problem-1%2F</url>
      <content type="text"><![CDATA[在使用eclipse的时候遇到到很多问题，在这里记录一下。 Failed to create the Java Virtual Machine 的问题的解决 path等的配置都没有问题，但是运行eclipse的时候还是无法运行 ，那么怎么解决呢？ 在eclipse文件夹下找到eclipse.ini 文件 打开修改为下面 -startup plugins/org.eclipse.equinox.launcher_1.3.0.v20120522-1813.jar --launcher.library plugins/org.eclipse.equinox.launcher.win32.win32.x86_1.1.200.v20120913-144807 -product com.android.ide.eclipse.adt.package.adtproduct -showsplash org.eclipse.platform --launcher.XXMaxPermSize 128m --launcher.defaultAction openFile -vmargs -Dosgi.requiredJavaVersion=1.6 -XX:MaxPermSize=256m -Xms512m -Xmx512m 即修改这几个地方：--launcher.XXMaxPermSize 128m -Dosgi.requiredJavaVersion=1.7 -XX:MaxPermSize=256m -Xms512m -Xmx512m]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[404界面的样式表无法加载问题]]></title>
      <url>%2F2015%2F10%2Fblog-404-style-not-found%2F</url>
      <content type="text"><![CDATA[今天终于发现了404页面样式表无法加载的的解决方法。 原先的时候是当输入的域名后有多个/的时候404页面的样式表无法加载，比如访问的页面是 http://magicer.xyz/dd/d。此时就无法加载样式表，而如果网址是 http://magicer.xyz/dd样式表就可以加载。处了此问题后，问题一直没有解决，但是今天突然发现了解决方法 原先的link是 1&lt;link rel=&quot;stylesheet&quot; media=&quot;screen&quot; href=&quot;styl4.css&quot;&gt; 而现在是 1&lt;link rel=&quot;stylesheet&quot; media=&quot;screen&quot; href=&quot;/styl4.css&quot;&gt; 只加了个`/``问题就解决了，但是 在电脑上测试的时候无法加载样式表，但是传到服务器上之后就可以。头像的问题一样如此解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Animation基础（一）]]></title>
      <url>%2F2015%2F10%2Fthe-basic-of-android-animation%2F</url>
      <content type="text"><![CDATA[视图动画（View Animation） 主要有AlphaAnimation ,RotateAnimation,TranslateAnimation,ScaleAnimation四种动画方式，在3.0之前广泛使用，但是由于不具有交互性（当View发生视图动画后，其响应事件的位置仍然在动画前的地方），渐渐的属性动画使用的多起来。一般试图动画制作普通的动画效果，不做交互。优点就是效率高使用方便。 通过XML定义动画在anim文件夹下创建，通过xml创建的动画可读性较好。12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:interpolator="@[package:]anim/interpolator_resource" android:shareInterpolator=["true" | "false"] &gt; &lt;alpha android:fromAlpha="float" android:toAlpha="float" /&gt; &lt;scale android:fromXScale="float" android:toXScale="float" android:fromYScale="float" android:toYScale="float" android:pivotX="float" android:pivotY="float" /&gt; &lt;translate android:fromXDelta="float" android:toXDelta="float" android:fromYDelta="float" android:toYDelta="float" /&gt; &lt;rotate android:fromDegrees="float" android:toDegrees="float" android:pivotX="float" android:pivotY="float" /&gt; &lt;set&gt; ... &lt;/set&gt;&lt;/set&gt; 下面来解释一下：android:interpolator ：表示动画集合采用的插值器，插值器影响动画的速度。android:shareInterpolator ：表示集合中的动画是否和集合公用同一个插值器。pivot：支点，枢纽； 通过xml创建的动画怎么使用呢：12Animation animation=AnimationUtils.loadAnimation(this,R.anim.viewanimation);view.startAnimation(animation); 透明度动画AlphaAnimation这个应该很清楚，设置开始值，结束值即可。123456AlphaAnimation aa=new AlphaAnimation(0,1);aa.setDuration(1000);View.startAnimation(aa);/** public AlphaAnimation (float fromAlpha, float toAlpha)*/ 位移动画 TranslateAnimation1234567891011121314151617TranslateAnimation ta=new TranslateAnimation(0,300,0,300);ta.setDuration(1000);View.startAnimation(ta);/**构造方法一：*public TranslateAnimation (float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)*//**构造方法二*public TranslateAnimation (int fromXType, float fromXValue, int toXType, float toXValue, int fromYType, float fromYValue, int toYType, float toYValue)*type的值是：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF,* Animation.RELATIVE_TO_PARENT 之一*/ 缩放动画 ScaleAnimation1234567891011121314151617181920212223ScaleAnimation sa=new ScaleAnimation(0,1,0,1);sa.setDuration(1000);View.startAnimation(sa);/**构造方法一*public ScaleAnimation (float fromX, float toX, float fromY, float toY)*//**构造方法二*public ScaleAnimation (float fromX, float toX, float fromY, float toY, float pivotX, float pivotY)*//**构造方法三*public ScaleAnimation (float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)*type的值是：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, *Animation.RELATIVE_TO_PARENT 之一*/ 旋转动画 RotateAnimation123456789101112131415161718192021RotateAnimation ra=new RotateAnimation(0,360,100,100);ra.setDuration(1000);View.startAnimation(ra);/**构造方法一*public RotateAnimation (float fromDegrees, float toDegrees)*//**构造方法二*public RotateAnimation (float fromDegrees, float toDegrees, float pivotX, float pivotY)*pivotX等于0是左边 Y=0是上边*//**构造方法三*public RotateAnimation (float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)*type的值是：Animation.ABSOLUTE, Animation.RELATIVE_TO_SELF, *Animation.RELATIVE_TO_PARENT 之一*/ 动画集合SetAnimation动画集合简单只需要把需要的动画add上就OK了。123456789101112AnimationSet as=new AnimationSet(true);as.setDuration(1000);AlphaAnimation alphaAnimation=new AlphaAnimation(1,0);alphaAnimation.setDuration(1000);as.addAnimation(alphaAnimation);RotateAnimation rotateAnimation=new RotateAnimation(0,360);rotateAnimation.setDuration(1000);as.addAnimation(rotateAnimation);View.startAnimation(as);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 中实现“再按一次退出程序”的提醒]]></title>
      <url>%2F2015%2F10%2Fpress-again-to-quit%2F</url>
      <content type="text"><![CDATA[见很多软件都有 按一次退出程序的提醒，觉得挺人性化，便从网上找到了代码，在这里记录一下：12345678910111213141516private long exitTime=0; @Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN) &#123; if ((System.currentTimeMillis() - exitTime) &gt; 2000) &#123; Toast.makeText(this, &quot;再按一次退出程序&quot;, Toast.LENGTH_SHORT).show(); exitTime = System.currentTimeMillis(); &#125; else &#123; finish(); System.exit(0); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 中 ListView 的使用]]></title>
      <url>%2F2015%2F10%2Fandroid-listview-general%2F</url>
      <content type="text"><![CDATA[ListView是android应用开发中使用频率非常高的一个系统组件，几乎所有的应用中都要用到，尽管现在RecycleView有想要替代ListView的意味，但ListView仍然很重要。所以ListView值得我们深入的研究。下面就记录下ListView的使用。 ViewHolder使用ViewHolder模式能够提高ListView的效率.基本的使用方法如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ViewHolderAdapter extends BaseAdapter &#123; private List&lt;String&gt; mData; private LayoutInflater mInflater; public ViewHolderAdapter(Context context,List&lt;String&gt; data )&#123; this.mData=data; mInflater=LayoutInflater.from(context); &#125; @Override public int getCount() &#123; return mData.size(); &#125; @Override public Object getItem(int position) &#123; return mData.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder=null; //判断是否缓存 if (convertView==null)&#123; holder=new ViewHolder(); //实例化布局 convertView=mInflater.inflate(R.layout.listitem,null); holder.img=(ImageView)convertView.findViewById(R.id.imageView); holder.title=(TextView)convertView.findViewById(R.id.textView); convertView.setTag(holder); &#125;else &#123; //通过Tag找到缓存的布局 holder=(ViewHolder)convertView.getTag(); &#125; holder.img.setBackgroundResource(R.mipmap.ic_launcher); holder.title.setText(mData.get(position)); return convertView; &#125; //自定义的ViewHolder类 final class ViewHolder&#123; public ImageView img; public TextView title; &#125;&#125; ListView样式divider:分割线颜色，diverHeight:分割线宽度，scrollbars=none:去掉滑动条，listSelector：取消点击效果 （transparent：透明的）12345678910111213&lt;ListView android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/listView" android:divider="@android:color/darker_gray" android:dividerHeight="1dp" android:scrollbars="none" android:listSelector="@android:color/transparent"/&gt;&lt;ImageView android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/empty_listview" android:src="@mipmap/ic_launcher"/&gt; 通常可以添加一个默认的图片，在ListView Item 为空的时候显示，12mListView= (ListView) findViewById(R.id.listView);mListView.setEmptyView(findViewById(R.id.empty_listview)); ListView动态修改12mData.add("iMac");mAdapter.notifyDataSetChanged();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio 快捷键的使用]]></title>
      <url>%2F2015%2F10%2Fandroid-studio-keymap%2F</url>
      <content type="text"><![CDATA[Android Studio 是Google官方的安卓开发IDE ，提供了集成的Android开发工具用于开发和调试，基于Gradle的构建支持。 用好Android Studio 快捷键是必须要掌握的，下面介绍一下AS 的常用快捷键： 常用：Ctrl+Alt +L: 格式化代码（在ubuntu上可能冲突，锁屏快捷键，修改系统的快捷键即可）Alt+Insert: 生成代码（get set方法，构造函数等）Ctrl+Y: 删除行Ctrl+O 显示父类所有的方法Ctrl+J： 自动代码Ctrl+E 打开最近的文件Ctrl+Shift+Backspace 跳转到上次编辑的地方Ctrl+F12 显示当前文件的结构Alt+Q 可以看到当前方法的声明Ctrl+P 显示参数信息Ctrl+Shift+Insert 可以选择剪贴板内容并插入 快捷键：Alt+回车: 导入包，自动修正Ctrl+N: 查找类Ctrl+Shift+N: 查找文件Ctrl+Alt+L： 格式化代码Ctrl+Alt+O: 优化导入的包和类Alt+Insert: 生成代码（get set方法，构造函数等）Ctrl+E或Alt+Space+C: 最近更改的代码Ctrl+Y: 删除行Ctrl+F: 查找文本Ctrl+R： 替换文本Ctrl+D: 集合了复制粘贴Ctrl+space 输入代码时按次组合键会列出与之相匹配的类，方法名，成员变量（支持XML）Ctrl+向上箭头或向下箭头： 在有自动匹配下拉列表时，次快捷键会自动关闭下拉列表 光标移动到下一行Ctrl+F 搜索Ctrl+Shift+A：快速查找android studio中的菜单Ctrl+B 直接跳转到类，方法，成员变量定义的地方 （Ctrl+鼠标左键）Ctrl+O 显示父类所有的方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio使用中的问题]]></title>
      <url>%2F2015%2F10%2Fandroid-studio-basic%2F</url>
      <content type="text"><![CDATA[Android Studio 是Google官方的安卓开发IDE，基于Gradle构建app。为了用上as，博主专门加了块内存条（4G）,话说4G的内存真的不够用，开ide在加上虚拟器就够呛了，不过加了内存条后Win有时候会进不去，可能是不兼容吧，嫌麻烦就没在换，反正ubuntu上可以用，这都是题外话了。 添加主题 as上的配色方案真的是不忍直视，在这里导入第三方的配色方案； 第三方主题:http://www.ideacolorthemes.org/home/ 下载后：File-&gt;import seetting-&gt;下载主题的路径；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客主题NexT使用自定义的CSS样式]]></title>
      <url>%2F2015%2F10%2Fhexo-custom-style%2F</url>
      <content type="text"><![CDATA[今天，创建自己的about页面的时候，像使用自定义的css样式，就像这是不是NexT可以使用自定义的CSS样式，片尝试了一下，还是可以的，因为markdown支持html标签，使用自定义的CSS样式还是不错的。下面总结一下具体的使用过程： 添加样式支持 为了不吧原先的像是文件搞得太乱，这里，添加子集的样式文件。 首先，在样式文件的source文件夹下找到css文件夹，打开main.styl文件，在最后添加： 123//My Layer//--------------------------------------------------@import &quot;_my/mycss&quot;; 新建自定义样式找到样式文件夹css 新建_my文件夹，在其中新建mycss.styl文件，之后就可以按照stylus的格式自定义样式了。 例子例如：我想在文章中添加个自定义样式的按钮，怎么做呢？？？ 打开新建的mycss.styl文件，在其中添加样式： 123456789101112131415161718192021.myButton &#123; background-color:#0f94bd; -moz-border-radius:15px; -webkit-border-radius:15px; border-radius:15px; display:inline-block; cursor:pointer; color:#ffffff; font-family:Arial; font-size:17px; padding:11px 27px; text-decoration:none; text-shadow:0px 1px 0px #2f6627;&#125;.myButton:hover &#123; background-color:#5cbf2a;&#125;.myButton:active &#123; position:relative; top:1px;&#125; (ps:这里直接使用的css的格式写的，因为css的代码在网上很好找到，而stylus预处理器的就不那么容易找到了，stylus一样支持css格式，所以在这里直接使用了css文件，没有写成stylus语法。其实让我写我也不会，哈哈！) 引用：在想要引用的时候添加1&lt;a href=&quot;#&quot; class=&quot;myButton&quot;&gt;MyButton&lt;/a&gt; 样式如下：MyButton效果已经出来了，怎么样？？是不是瞬间高大上。。有想要使用的样式，自行百度，找到后粘贴即可使用。 推荐推荐一个css button样式的生成网站：http://www.bestcssbuttongenerator.com/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客转移 从github到gitcafe]]></title>
      <url>%2F2015%2F10%2FHexo-github-gitcafe%2F</url>
      <content type="text"><![CDATA[用Hexo和github搭建博客很长时间了，考虑到自己的博客可能主要的用户都会是国内的，所以想吧博客从github上转移到gitcafe上来，一开始打算转移到coding.net上，不过Coding不能自定义域名所以就没有用Coding，不过访问 magicer.coding.io 也能访问我的博客，因为代码也同步到Coding上来了。 下面就记录一下自己博客转移的过程。 gitcafe的使用 首先注册gitcafe账户创建项目，此处我创建的项目名跟我的用户名一样。 随后，在自己的家目录的.ssh/目录下找到id_rsa.pub文件，打开后复制内容粘贴到gitcafe的 SSH公钥管理中新建SSH公钥（如果配置过github会存在.ssh/文件夹，如果没有的话，需要配置，配置方法见：配置github，测试的时候只需要将github换成gitcafe即可。） 托管代码到gitcafe 在这里说明，我安装了git插件，安装方法： 1npm install hexo-deployer-git --save 在_config.yml.中配置（可以同时托管代码在github和gitcafe上，） 12345678910111213deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message]#或者:deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] pages服务 托管上代码之后应该分支应该会直接是gitcafe-pages分支，之后项目设置自定义域名 修改域名的解析搬移即可完成。 新建CNAME解析，解析到gitcafe.io,现在gitcafe已经不支持A记录解析方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客主题换成了NexT]]></title>
      <url>%2F2015%2F08%2Fblog-theme-changed%2F</url>
      <content type="text"><![CDATA[博客主题由原先的Jacman换成了现在高大上的NexT主题，Jacman主题显得过于花哨，而NexT却显得高大上一点。比较了一下，还是更喜欢NexT的感觉。下面就简单说明一下过程。详细的下载安装及设置教程在这里：http://theme-next.iissnan.com/ 效果图就不用看了吧，毕竟效果已经摆出来了，如果你也喜欢，那就动手吧。 自定义NexT 1、添加Title 。 NexT主题的Title和网站主页上的左上角的LOGO字体是一样的，在这里我想设置成不一样的怎么办呢？其实很简单，只需要在配置文件中添加一个name（注意：这个配置文件的位置是HEXO的配置文件不是主题的配置文件。 ps：我觉得还是用logo比较好，由于子集以前就是用的name，在这里就不更改了）12title: Magicername: Magicer 然后，在NexT主题文件夹中找到layout文件夹下的_partials文件夹下的header.swig文件 找到： 1&lt;span class=&quot;site-title&quot;&gt;&#123;&#123; config.title &#125;&#125;&lt;/span&gt; 将config.title修改为config.name即可2、使页面地步链接到about界面 找到：主题layout文件夹下的_partials文件夹下的 footer.swig文件：找到： 1&lt;span class=&quot;author&quot; itemprop=&quot;copyrightHolder&quot;&gt;&#123;&#123; config.author &#125;&#125;&lt;/span&gt; 将其改为 123&lt;a class=&quot;theme-link&quot; href=&quot;/about/index.html&quot;&gt; &lt;span class=&quot;author&quot; itemprop=&quot;copyrightHolder&quot;&gt;&#123;&#123; config.author &#125;&#125;&lt;/span&gt;&lt;/a&gt; 当然也可以连接到一个网址，比如我的设置就是这样的： 123&lt;a class=&quot;theme-link&quot; href=&quot;http://magicer.xyz&quot;&gt; &lt;span class=&quot;author&quot; itemprop=&quot;copyrightHolder&quot;&gt;&#123;&#123; config.author &#125;&#125;&lt;/span&gt;&lt;/a&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决vim使用过程中与遇到问题]]></title>
      <url>%2F2015%2F08%2Fvim-notes%2F</url>
      <content type="text"><![CDATA[vim中无法输入中文或输入中文乱码 打开终端输入：12vim ～/.vimrc##也可以 vim /etc/vim/vimrc 在其中输入以下代码：12345set encoding=UTF-8set langmenu=zh_CN.UTF-8language message zh_CN.UTF-8set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1set fileencoding=utf-8]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[（转）Android开发效率—Eclipse快捷键]]></title>
      <url>%2F2015%2F05%2Fandroid-eclipse-hot-key%2F</url>
      <content type="text"><![CDATA[很多过去使用Visual Studio开发软件的网友可能不熟悉Java开发环境，今天Android开发网告诉大家一些提高Android开发效率的Eclipse快捷键，可以有效率的帮助我们管理代码和减少键盘输入。Eclipse相对于Visual Studio而言使用Java开发，响应速度和稳定性上有很大的欠缺，这些我们目前只能容忍下。 1转载自http://www.cnblogs.com/lm3515/archive/2011/03/16/1985671.html 比较常用的Android123整理如下: 自动补充import Package Ctrl+Shift+O，这里O代表Organize Import的意思。 格式化代码缩进 Ctrl+Shift+F，这里面我们可以记忆F为Format格式化的意思。 快速查找代码 Ctrl+F，撤消到上一次Ctrl+Z 智能内容感知 Alt+/ ，该快捷键可以方便的匹配我们使用的类信息，/ 在键盘上和?是同一个按键。 调用运行Run As对话框可以使用Ctrl+F11，如果为Debug调试方式可以直接使用F11。 生成一个板块注释Alt+Shift+J ，单行注释为Ctrl+/键 用Eclipse开发，不知道快捷键可不行啊。熟悉快捷键可以大大的提高效率： ##常用Ctrl+M 当前窗口最大化Ctrl+F7 视窗口切换Ctrl+F8 模式切换Ctrl+F6 编辑窗口切换(手指张得太大不雅观啊)Ctrl+E 编辑窗口切换(这个比较文雅点??)Alt+← 前一个编辑的页面Alt+→ 下一个编辑的页面Ctrl+Alt+↓ 复制(增加)当前行到下一行Ctrl+Alt+↑ 复制(增加)当前行到上一行Alt+↓ 当前行和下面一行交互位置(用不着剪切了)Alt+↑ 当前行和上面一行交互位置Ctrl+D 删除当前行Alt+Enter 显示当前选择文件的属性Shift+Enter 在当前行插入空行(下一行)Shift+Ctrl+Enter 在当前行插入空行(上一行)Ctrl+Q 定位到最后编辑的地方Ctrl+L 定位在具体某行Ctrl+/ 注释当前行(可多行),再按则取消注释Ctrl+Shift+R 找文件Ctrl+Shift+T 找类Ctrl+K 选中的Word快速定位到下一个Ctrl+Shift+K 选中的Word快速定位到上一个Ctrl+Shift+U 选中后列出查询到的结果Ctrl+/(小键盘) 折叠当前类中的所有代码Ctrl+×(小键盘) 展开当前类中的所有代码Ctrl+Shift+P 定位到对于的匹配符(如{},())CTRL+SHIFT+X 切换字符的大小写(大写)CTRL+SHIFT+Y 切换字符的大小写(小写)Ctrl+1 当某行出错时或警告时,跳出帮助Ctrl+Shift+F 格式排版Alt+Shift+R 重命名 (改量和类名时很方便)Alt+Shift+C 修改函数结Alt+Shift+M 重构方法 (选中要重构方法,再生成个新方法)Alt+Shift+Z 重构恢复Ctrl+W 关闭当前窗口Ctrl+Shift+F4 关闭所有打开的窗口Ctrl+Shift+O ： import相关类，同时若已经import的类，没有被用到，就删除。sysout-&gt;Ctrl+Space-&gt;System.out.println()Window-&gt;reference-&gt;Workbench-&gt;Keys 有兴趣的可以自定义热键 编辑作用域 功能 快捷键全局 查找并替换 Ctrl+F文本编辑器 查找上一个 Ctrl+Shift+K文本编辑器 查找下一个 Ctrl+K全局 撤销 Ctrl+Z全局 复制 Ctrl+C全局 恢复上一个选择 Alt+Shift+↓全局 剪切 Ctrl+X全局 快速修正 Ctrl1+1全局 内容辅助 Alt+/全局 全部选中 Ctrl+A全局 删除 Delete全局 上下文信息 Alt+？Alt+Shift+?Ctrl+Shift+SpaceJava编辑器 显示工具提示描述 F2Java编辑器 选择封装元素 Alt+Shift+↑Java编辑器 选择上一个元素 Alt+Shift+←Java编辑器 选择下一个元素 Alt+Shift+→文本编辑器 增量查找 Ctrl+J文本编辑器 增量逆向查找 Ctrl+Shift+J全局 粘贴 Ctrl+V全局 重做 Ctrl+Y 查看作用域 功能 快捷键全局 放大 Ctrl+=全局 缩小 Ctrl+- 窗口作用域 功能 快捷键全局 激活编辑器 F12全局 切换编辑器 Ctrl+Shift+W全局 上一个编辑器 Ctrl+Shift+F6全局 上一个视图 Ctrl+Shift+F7全局 上一个透视图 Ctrl+Shift+F8全局 下一个编辑器 Ctrl+F6全局 下一个视图 Ctrl+F7全局 下一个透视图 Ctrl+F8文本编辑器 显示标尺上下文菜单 Ctrl+W全局 显示视图菜单 Ctrl+F10全局 显示系统菜单 Alt+- 导航作用域 功能 快捷键Java编辑器 打开结构 Ctrl+F3全局 打开类型 Ctrl+Shift+T全局 打开类型层次结构 F4全局 打开声明 F3全局 打开外部javadoc Shift+F2全局 打开资源 Ctrl+Shift+R全局 后退历史记录 Alt+←全局 前进历史记录 Alt+→全局 上一个 Ctrl+,全局 下一个 Ctrl+.Java编辑器 显示大纲 Ctrl+O全局 在层次结构中打开类型 Ctrl+Shift+H全局 转至匹配的括号 Ctrl+Shift+P全局 转至上一个编辑位置 Ctrl+QJava编辑器 转至上一个成员 Ctrl+Shift+↑Java编辑器 转至下一个成员 Ctrl+Shift+↓文本编辑器 转至行 Ctrl+L 搜索作用域 功能 快捷键全局 出现在文件中 Ctrl+Shift+U全局 打开搜索对话框 Ctrl+H全局 工作区中的声明 Ctrl+G全局 工作区中的引用 Ctrl+Shift+G 文本编辑作用域 功能 快捷键文本编辑器 改写切换 Insert文本编辑器 上滚行 Ctrl+↑文本编辑器 下滚行 Ctrl+↓ 文件作用域 功能 快捷键全局 保存 Ctrl+XCtrl+S全局 打印 Ctrl+P全局 关闭 Ctrl+F4全局 全部保存 Ctrl+Shift+S全局 全部关闭 Ctrl+Shift+F4全局 属性 Alt+Enter全局 新建 Ctrl+N 项目作用域 功能 快捷键全局 全部构建 Ctrl+B 源代码作用域 功能 快捷键Java编辑器 格式化 Ctrl+Shift+FJava编辑器 取消注释 Ctrl+\Java编辑器 注释 Ctrl+/Java编辑器 添加导入 Ctrl+Shift+MJava编辑器 组织导入 Ctrl+Shift+OJava编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。也可以使用Ctrl+1自动修正。 运行作用域 功能 快捷键全局 单步返回 F7全局 单步跳过 F6全局 单步跳入 F5全局 单步跳入选择 Ctrl+F5全局 调试上次启动 F11全局 继续 F8全局 使用过滤器单步执行 Shift+F5全局 添加/去除断点 Ctrl+Shift+B全局 显示 Ctrl+D全局 运行上次启动 Ctrl+F11全局 运行至行 Ctrl+R全局 执行 Ctrl+U 重构作用域 功能 快捷键全局 撤销重构 Alt+Shift+Z全局 抽取方法 Alt+Shift+M全局 抽取局部变量 Alt+Shift+L全局 内联 Alt+Shift+I全局 移动 Alt+Shift+V全局 重命名 Alt+Shift+R全局 重做 Alt+Shift+Y]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[eclipse-android自动提示代码]]></title>
      <url>%2F2015%2F05%2Feclipse-android-auto%2F</url>
      <content type="text"><![CDATA[##（一）设置 java 文件的代码提示功能 打 开 Eclipse 依次选择 Window &gt; Preferences &gt; Java &gt; Editor - Content Assist &gt; Auto activation triggers for Java ，设置框中默认是一个点，1.abcdefghijklmnopqrstuvwxyz(, （二）设置 xml 文件的代码提示功能打 开 Eclipse 依次选择 Window &gt; Preferences &gt; Xml &gt; Xml Files &gt; Editor &gt; Content Assist &gt; Auto activation &gt; Prompt when these characters are inserted ，设置框中默认是 &lt;=: ， 1&lt;=:.abcdefghijklmnopqrstuvwxyz(, 把delay该小一点。默认为500]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git tag 、branch的使用]]></title>
      <url>%2F2015%2F05%2Fgit-tag-branch%2F</url>
      <content type="text"><![CDATA[Git是一个免费的、分布式的版本控制工具，或是一个强调速度快的源代码管理工具。Git诞生于2005年，最初是Linus Torvalds开发出来用于管理Linux内核的开发。 （一）git tag列出git中现有标签 要想列出git中现有的所有标签，输入’git tag’命令运行即可： 123git tagv0.1v1.3 1git fetch origin tag &lt;tagname&gt; ##获取远程tag 创建标签轻量级标签 轻量级标签跟分枝一样，不会改变。它就是针对某个特定提交的指针 带注释的标签 然而，带注释的标签是git仓库中的对象，它是一组校验和，包含标签名、email、日期，标签信息，GPG签名和验证 1234567$ git tag -a v1.4 -m ‘version 1.4‘$ git tagv0.1v1.3v1.4$git show$git push origin --delete tag &lt;tagname&gt; ##删除远程tag 可以使用 git show 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。 ###发布标签 通常的git push不会将标签对象提交到git服务器，我们需要进行显式的操作： 12$ git push origin v0.1.2 # 将v0.1.2标签提交到git服务器$ git push origin –tags # 将本地所有标签一次性提交到git服务器 ##（二）git branch 1234567git branch -a ##显示远程分支 红色为远程分支git branch -d gh-pages ##删除本地分支git push origin :branch_name ##删除远程分支git branch branch_namegit commit git push origin branch_name ##提交本地分支 （三）在shell中显示分支名字 只需要把下面代码添加到 ～/.bashrc文件中即可。 1234567891011121314151617181920212223 ## Parses out the branch name from .git/HEAD:find_git_branch () &#123; local dir=. head until [ &quot;$dir&quot; -ef / ]; do if [ -f &quot;$dir/.git/HEAD&quot; ]; then head=$(&lt; &quot;$dir/.git/HEAD&quot;) if [[ $head = ref:\ refs/heads/* ]]; then git_branch=&quot; | $&#123;head#*/*/&#125;&quot; elif [[ $head != &apos;&apos; ]]; then git_branch=&quot; | (detached)&quot; else git_branch=&quot; | (unknow)&quot; fi return fi dir=&quot;../$dir&quot; done git_branch=&apos;&apos;&#125;green=$&apos;\[\e[1;32m\]&apos;normal=$&apos;\[\e[m\]&apos;PROMPT_COMMAND=&quot;find_git_branch; $PROMPT_COMMAND&quot;PS1=&quot;\u@\h:\w$green\$git_branch $normal\$ &quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[配置github]]></title>
      <url>%2F2015%2F04%2Fgithub-config%2F</url>
      <content type="text"><![CDATA[电脑系统重新安装了，很多软件都需要重新设置，鼓捣了很长时间，顺便记录一下各种配置及修改。感觉好累啊。 生成ssh123ssh-keygen -t rsa -C &quot;your_email@example.com&quot;# Creates a new ssh key, using the provided email as a label# Generating public/private rsa key pair. 第一步不用直接回车就可以，之后按照流程输入就行，然后把id_rsa.pub文件中的内容复制到github设置里面的ssh中 测试是否成功：1ssh -T git@github.com 当出现以下提示时即设置成功12Hi username! You&apos;ve successfully authenticated, but GitHub does not# provide shell access. 配置git在终端输入12git config --global user.name &quot;username&quot;git config --global user.email &quot;email&quot; 测试是否设置正确：1git config --global --list]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime_text 的安装与使用]]></title>
      <url>%2F2015%2F04%2Fsublime-text2%2F</url>
      <content type="text"><![CDATA[Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。 SublimeText具有漂亮的用户界面和强大的功能，例如代码缩略图，Python的插件，代码段等。还可自定义键绑定，菜单和工具栏。Sublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。Sublime Text 是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。 下载地址： http://www.sublimetext.com/ 安装 12345add-apt-repository ppa:webupd8team/sublime-text-2apt-get updateapt-get install sublime-text 安装控制器(仅适用于text2)： ctrl+`,调出控制台： 输入：1import urllib2,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib2.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) ##sublime text3安装控制器 1import urllib.request,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib.request.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 插件推荐： 1：emmet：前段必备 2：autofilename 3:allautocomplete 4:IconFont 5:Sublime CodeIntel:代码自动提示 6：Bracket Highlighter：代码匹配 7：Sublime Prefixr：Prefixr，CSS3 私有前缀自动补全 8：ConvertToUTF8：在打开文件时将其他格式的代码转成UTF-8(此插件很有必要安装啊) 9：Pretty Json:格式化json文件(在json如此流行的时代怎么能不安装此插件) 添加快捷方式：（在用户自定义的快捷键文件中添加） 1&#123; &quot;keys&quot;: [&quot;ctrl+shift+j&quot;], &quot;command&quot;: &quot;prettify_json&quot; &#125; Emmet插件的使用 快捷： 生成html格式 输入 html:5 简写Div div.container]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu安装32位库]]></title>
      <url>%2F2015%2F04%2Fubuntu-32bit-lib%2F</url>
      <content type="text"><![CDATA[很多软件只有32位的，有的依赖32位库还挺严重的；从ubuntu 13.10已经废弃了ia32-libs，但可以使用多架构，安装软件或包apt-get install program:i386。有的还是觉得烦，想一步到位安装所有的以前的ia32-libs，可以使用以下方法： 12345sudo -icd /etc/apt/sources.list.decho &quot;deb http://archive.ubuntu.com/ubuntu/ raring main restricted universe multiverse&quot; &gt;ia32-libs-raring.listapt-get updateapt-get install ia32-libs 复制代码PS:这种方法肯定能安装上ia32-libs，但由于添加的是13.04的源，所以有没有混淆暂时不清楚，网上也有很多用新立德软件包管理器这样做；够狠，你就这么干。也可以这么安装了ia32-libs后，把/etc/apt/sources.list.d目录下的ia32-libs-raring.list删掉，然后再sudo apt-get update]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装Hexo，搭建博客]]></title>
      <url>%2F2015%2F04%2Fhexo-install%2F</url>
      <content type="text"><![CDATA[Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。 而架设Hexo的环境更简单了 不需要lnmp/lamp这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务比如Hexo的官方网站http://hexo.io 就是托管于github的pages服务上 系统重装之后用hexo搭建的博客没有了，又花了整理了很长时间才搭建完成，在这里记录一下。 安装nodejs安装钱需要系统上有python g++ 和gcc下载nodejs下载完了之后解压12345tar zxvf node-v0.12.2.tar.gz -C /optcd /opt/node-v0.12.2./configure make sudo make install 安装完成后检查1node -version 安装git1sudo apt-get install git-core 安装hexo1npm install hexo -g 进入想要写文章的博客目录。运行 hexo init之后运行 npm install]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sublime输入中文]]></title>
      <url>%2F2015%2F04%2Fsublime-chinese%2F</url>
      <content type="text"><![CDATA[在Ubuntu 14.04中安装了SublimeText 3之后发现既然不支持输入中文，于是在网上搜罗一下，发现很多人遇到了同样的问题，但是解决办法大该就只有一个。下面根据自身的安装及解决办法总结如下： 1. SublimeText 3的安装安装方式有多种，本文所描述的是从官方网站上下载64位的.deb文件 ，具体为http://c758482.r82.cf2.rackcdn.com/sublime-text_build-3059_amd64.deb文件，下载后双击即会自动使用默认的安装软件安装。 2. 相关依赖软件的安装 1sudo apt-get install build-essential libgtk2.0-dev ##3. 拷贝如下代码到文件sublime-imfix.c文件中，该文件需要自己创建，随便放到那里都行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* * sublime-imfix.c * Use LD_PRELOAD to interpose some function to fix sublime input method support for linux. * By Cjacker Huang &lt;jianzhong.huang at i-soft.com.cn&gt; * * * gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC * LD_PRELOAD=./libsublime-imfix.so sublime_text */#include &lt;gtk/gtk.h&gt;#include &lt;gdk/gdkx.h&gt;typedef GdkSegment GdkRegionBox;struct _GdkRegion&#123; long size; long numRects; GdkRegionBox *rects; GdkRegionBox extents;&#125;;GtkIMContext *local_context;voidgdk_region_get_clipbox (const GdkRegion *region, GdkRectangle *rectangle)&#123; g_return_if_fail (region != NULL); g_return_if_fail (rectangle != NULL); rectangle-&gt;x = region-&gt;extents.x1; rectangle-&gt;y = region-&gt;extents.y1; rectangle-&gt;width = region-&gt;extents.x2 - region-&gt;extents.x1; rectangle-&gt;height = region-&gt;extents.y2 - region-&gt;extents.y1; GdkRectangle rect; rect.x = rectangle-&gt;x; rect.y = rectangle-&gt;y; rect.width = 0; rect.height = rectangle-&gt;height; //The caret width is 2; //Maybe sometimes we will make a mistake, but for most of the time, it should be the caret. if (rectangle-&gt;width == 2 &amp;&amp; GTK_IS_IM_CONTEXT(local_context)) &#123; gtk_im_context_set_cursor_location(local_context, rectangle); &#125;&#125;//this is needed, for example, if you input something in file dialog and return back the edit area//context will lost, so here we set it again.static GdkFilterReturn event_filter (GdkXEvent *xevent, GdkEvent *event, gpointer im_context)&#123; XEvent *xev = (XEvent *)xevent; if (xev-&gt;type == KeyRelease &amp;&amp; GTK_IS_IM_CONTEXT(im_context)) &#123; GdkWindow *win = g_object_get_data(G_OBJECT(im_context), "window"); if (GDK_IS_WINDOW(win)) &#123; gtk_im_context_set_client_window(im_context, win); &#125; &#125; return GDK_FILTER_CONTINUE;&#125;void gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window)&#123; GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context)); klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-&gt;set_client_window) &#123; klass-&gt;set_client_window (context, window); &#125; if (!GDK_IS_WINDOW (window)) &#123; return; &#125; g_object_set_data(G_OBJECT(context), "window", window); int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if (width != 0 &amp;&amp; height != 0) &#123; gtk_im_context_focus_in(context); local_context = context; &#125; gdk_window_add_filter (window, event_filter, context);&#125; 按照文件头上注释所说的编译该文件，在终端里进入到存放该文件的目录中，输入如下命令： 1gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC 最后在当前目录下得到libsublime-imfix.so这个共享库。 4. 中文输入到这里默认已经装好了中文输入法（搜狗输入法linux版）。得到第3步中的库libsublime-imfix.so之后，先试试看是否能正常使用中文输入法，在终端中输入如下命令： 1LD_PRELOAD=./libsublime-imfix.so subl #subl是安装好SublimeText 3后的程序启动命令 如果一切正常，在启动之后，搜狗输入法就能可以输入了。 5. 为了方便在第4步中如果每次都输入LD_PRELOAD这样显得太不方便了，在这里提供简单修改图标连接的方式，快速打开SublimeText。将libsublime-imfix.so拷贝到系统库的默认路径中： 1sudo cp libsublime-imfix.so /usr/lib/ 修改/usr/share/applications/sublime_text.desktop文件 1sudo vim /usr/share/applications/sublime_text.desktop 打开后将Exec=/opt/sublime_text/sublime_text %F修改为1Exec=bash -c &apos;LD_PRELOAD=/usr/lib/libsublime-imfix.so /opt/sublime_text/sublime_text&apos; %F 将Exec=/opt/sublime_text/sublime_text -n修改为 1Exec=bash -c &apos;LD_PRELOAD=/usr/lib/libsublime-imfix.so /opt/sublime_text/sublime_text&apos; -n 这样就通过快捷方式打开SublimeText 3就可以支持中文输入了。 注：第五步仅限使用.deb文件安装的情况，如果使用源码安装的则需要变通一下，写个脚本将LD_PRELOAD加上即可 本文转载自 http://blog.csdn.net/cywosp/article/details/32350899]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android初学常见的几个知识点]]></title>
      <url>%2F2015%2F04%2Fandroid-basic%2F</url>
      <content type="text"><![CDATA[ActivityActivity 是用户接口程序，原则上它会提供给用户一个交互式的接口功能。它是 android 应用程序的基本功能单元。Activity 本身是没有界面的。所以activity类创建了一个窗口，开发人员可以通过setContentView(View)接口把UI放到activity创建的窗口上，当activity指向全屏窗口时，也可以用其他方式实现：作为漂浮窗口（通过windowIsFloating的主题集合），或者嵌入到其他的activity（使用ActivityGroup）。activity是单独的，用于处理用户操作。几乎所有的activity都要和用户打交道 ###(一)Activity的生命周期 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.example.activity1;import android.app.Activity;import android.os.Bundle;import android.util.Log;public class MainActivity extends Activity &#123; private String TAG="TAG"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(TAG,"onCreate"); &#125; @Override protected void onStart() &#123; super.onStart(); Log.d(TAG,"onStart"); &#125; @Override protected void onResume() &#123; super.onResume(); Log.d(TAG,"onResume"); &#125; @Override protected void onPause() &#123; super.onPause(); Log.d(TAG,"onPause"); &#125; @Override protected void onRestart() &#123; super.onRestart(); Log.d(TAG,"onRestart"); &#125; @Override protected void onStop() &#123; super.onStop(); Log.d(TAG,"onStop"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.d(TAG,"onDestroy"); &#125;&#125; 程序启动时经历：onCreate–&gt;onStart–&gt;onResume按下返回键时：onPause–&gt;onStop–&gt;onDestroy按下home键时：onPause–&gt;onStop再次调用时：onRestart–&gt;onStart–&gt;onResume 打开另一个activity在onCreate()方法中添加以下代码来设置按钮button1的监听事件。前提是：布局文件中已经添加了id为button1的按钮。 12345678910Button btn =(Button) findViewById(R.id.button1); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent itn =new Intent(MainActivity.this,activity2.class); //此处的activity2为第二个类的名，MainActivity为当前类的名字。 startActivity(itn); &#125; &#125;); 在另外创建一个类继承自activity 和一个布局文件。 运行为android application.点击按钮即可进入另一个activity 。 可以在第二个activity中设置监听事件来关闭新打开的activity。（在第二个类文件的onCreate()方法中添加）代码如下： 12345678Button btn2=(Button) findViewById(R.id.btn2); btn2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125; &#125;); Notification应用实例代码：1234567891011121314151617181920212223public static final int NOTIFICATION_ID=200;private Button btn;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn=(Button) findViewById(R.id.btn_notification); btn.setOnClickListener(new View. OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub android.support.v4.app.NotificationCompat.Builder builder=new NotificationCompat.Builder(MainActivity.this); builder.setSmallIcon(R.drawable.ic_launcher); builder.setContentTitle("通知"); builder.setContentText("这是通知消息"); Notification notification=builder.build(); NotificationManager manager=(NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); manager.notify(NOTIFICATION_ID,notification); &#125; &#125;); &#125; ListView的使用及ArrayAdapter应用实例：123456789101112131415161718private ListView listview;private ArrayAdapter&lt;String&gt; arr_adapter;private SimpleAdapter simple_adapter;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); listview=(ListView) findViewById(R.id.listView1); String []arr_data=&#123;"姓名","性别","年龄"&#125;; //1,新建一个适配器 //2,配置数据项 //ArrayAdapter(上下文，当前listview加载的每一个列表项所对应的布局文件,数据源) arr_adapter=new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, arr_data); //3,视图（ListView）加载适配器 listview.setAdapter(arr_adapter); &#125; Toast的使用 ###（一）最简单的使用案例 123Toast.makeText( getBaseContext(), "需要显示的文字"， LENGTH_SHORT).show(); 地一个参数是上下文，第二个参数是需要显示的文字提示，第三个参数是显示的时间，最后调用show()方法显示出来。 （二）构建自己的toast样式 参见官方手册 12345678910111213141516171819 &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/toast_layout_root" android:orientation="horizontal" android:layout_width="fill_parent" android:layout_height="fill_parent" android:padding="8dp" android:background="#DAAA" &gt; &lt;ImageView android:src="@drawable/droid" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="8dp" /&gt; &lt;TextView android:id="@+id/text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="#FFF" /&gt;&lt;/LinearLayout&gt; 123456789101112 LayoutInflater inflater = getLayoutInflater();View layout = inflater.inflate(R.layout.custom_toast, (ViewGroup) findViewById(R.id.toast_layout_root));TextView text = (TextView) layout.findViewById(R.id.text);text.setText("This is a custom toast");Toast toast = new Toast(getApplicationContext());toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);toast.setDuration(Toast.LENGTH_LONG);toast.setView(layout);toast.show(); （三）toast的样式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android开发环境搭建]]></title>
      <url>%2F2015%2F03%2Fandroid-first-step%2F</url>
      <content type="text"><![CDATA[这学期有安卓课程，在搭建android环境的时候还是遇到了一些问题，所以决定整理一份关于 android环境搭建的教程留着以后使用。主要包括jdk的安装，android studio和eclipse的配置，和sdk的安装 主要是sdk的问题较为重要，毕竟在国内无法访问 ##（一）JDK的配置 ubtuntu环境下配置jdk 在官网下载jdk，地址为：JAVA下载链接这里我们选择Java SE 8u40 Linux64位：jdk-8u40-linux-x64.tar.gz。进入下载地址，下载之前需要接受许可协议。下载之后，进入下载目录将JDK包放到/opt/Java目录下： 1234sudo mkdir /opt/Javasudo mv jdk-8u40-linux-x64.tar.gz /opt/Javacd /opt/Javasudo tar -zxvf jdk-8u40-linux-x64.tar.gz。 然后是配置JAVA的环境变量，linux中配置环境变量有4个地方： /etc/environment：设置整个系统的环境，与登录用户无关 /etc/profile：为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行并从/etc/profile.d目录的配置文件中搜集shell的设置 /etc/bash.bashrc：为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取. ~/.bashrc：该文件包含专用于该登录用户bash shell的bash信息,当登录时以及每次打开新的shell时该该文件被读取。它可以把使用这些环境变量的权限控制到用户级别，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的.bashrc文件就可以了。 各配置的生效时间： /etc/environment：重启生效/etc/profile：注销后登录生效/etc/bash.bashrc：重新打开bash shell后生效~/.bahsrc：重新打开bash shell后生效 一般我们修改/etc/profile 即可：sudo gedit /etc/profile 在文件最后加上一下四行：1234export JAVA_HOME=/opt/Java/jdk1.7.0_55export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 保存后注销重新登陆即可生效（source /etc/profile 命令只是使得环境变量对当前的shell有效）。在终端运行一下命令看是否安装完成1java -version windows（二）android studio和eclipse的配置Eclipse下载地址android studio官方下载地址 推荐一个很好的网站上面有各种android开发需要的软件(android studio也可以从这里下载，毕竟官网进不去)http://www.androiddevtools.cn/ 在windows上eclipse直接解压就好。 eclipse配置ADT （1）打开eclipse找到 Help=&gt;install new software 在打开的界面中找到Add然后点击 打开后name随便输 location输入https://dl-ssl.google.com/android/eclipse/ 然后点击确定 如果https://dl-ssl.google.com/android/eclipse/ 慢的话可以换成 http://dl-ssl.google.com/android/eclipse/ 然后点确定（2）也可以离线安装 就是在上面推荐的网站上下载好ADT然后在打开的Add界面中点击Archive 找到下载的安装包，name随便填写一个即可。（安装的时候断开网，ADT可能会自动联网更新）安装完成后eclipse界面上会出现两个标志。在windows选项中找到preferences配置SDK路径 ##（三）SDK的安装配置 下载sdk并安装，后启动会自动更新。但观望无法访问，也可以看（四）解决此问题，当然也有替代方法： 找到Tools==&gt;options配置 打上勾之后，点击安装例如： ##（四）SDK的问题与解决方案 当进入sdk manager中时可能显示 Failed to fetch URL https://dl-ssl.google.com/android/repository/repository.xml, reason: java.security.cert.CertificateException: No name matching dl-ssl.google.com found 解决方法是在hosts文件下添加12345203.208.46.100 dl.google.com203.208.46.100 dl-ssl.google.com或64.233.167.104 dl.google.com64.233.167.104 dl-ssl.google.com ubuntu下的话打开终端运行 1sudo vim /etc/hosts 若是windows环境的话hosts文件在（修改的时候可能需要管理员权限）1C:\Windows\System32\drivers\etc]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建wordpress后出现的问题]]></title>
      <url>%2F2015%2F03%2Fwordpress-problems%2F</url>
      <content type="text"><![CDATA[####（一）出现 上传的文件尺寸超过php.ini中定义的upload_max_filesize值.的问题 找到php.ini文件 (一般在/etc/php /etc /usr/local/etc下)打开后找到upload_max_filesize修改其默认值（2M）。然后重启apache2（我用ubuntu14.04文件在/etc/php5/apache2下）。 ####（二）无法建立目录wp-content/uploads/2015/03。有没有上级目录的写权限？使用PHPMyAdmin进入数据库。数据库管理的高级管理可以进去。找到wordpress数据库，打开wp_options表修改表中键名为upload_path的键值 这个值是一个路径（可能在表的第二页）里面是空的，添加“wp-content/uploads”就解决了。＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝双引号必加！类似于注册表键值 ####（三）解决”要执行请求的操作，WordPress需要访问您网页服务器的权限”在/var/www/wordpress文件夹下的wp-config.php添加如下代码 define(&quot;FS_METHOD&quot;, &quot;direct&quot;); define(&quot;FS_CHMOD_DIR&quot;, 0777); define(&quot;FS_CHMOD_FILE&quot;, 0777); ####（四）解决无法创建文件夹的问题 在/ver/www/wordpress下，把wp-content的文件权限改成777 sudo chmod 777 wp-content]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用linux遇到的一些问题]]></title>
      <url>%2F2015%2F01%2Flinux-problems%2F</url>
      <content type="text"><![CDATA[使用ubuntu linux 遇到的一些问题及解决方法。 ubuntu的使用1.安装完ubuntu之后，windows分区无法挂载，出现如下图所示提示：解决方法：打开终端（快捷键ctrl+alt+t）输入：1sudo ntfsfix /dev/sda6 挂载系统盘时显示： Mounting volume… Windows is hibernated, refused to mount.FAILEDAttempting to correct errors…Processing $MFT and $MFTMirr…Reading $MFT… OKReading $MFTMirr… OKComparing $MFTMirr to $MFT… OKProcessing of $MFT and $MFTMirr completed successfully.Setting required flags on partition… OKGoing to empty the journal ($LogFile)… OKWindows is hibernated, refused to mount.Remount failed: Operation not permitted 问题待解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim使用技巧及基本操作]]></title>
      <url>%2F2015%2F01%2Fvim-note1%2F</url>
      <content type="text"><![CDATA[vim 的基本操作 基本操作复制粘贴yw复制光标所在单词yy复制当前行nyy复制n行y$复制光标所在位置到行末的字符p粘贴到光标后P粘贴到光标前d$删除光标至行尾的所有字符dd删除光标所在行ndd删除光标所在行在内的后n行。dw删除光标所在的单词x会删除光标下的字符。xp交换两个字符位置ddp 上下两行调换 插入a从光标后插入。i从光标前插入。A从行末插入。s先删除光标下字符，然后进入插入模式。o在本行的下方增加一行，并进入插入模式。O在本行的上方增加一行，并进入插入模式。 移动hjkl分别为左，下，上，右。$移动到行尾。0移动到行首。（移动到段落开头）移动到段落结尾gg跳到文件头。G移动到文件最后列M移动到视窗的中间列{}w/W光标移动到下一个字首e/E光标移动到下一个字末b/B光标移动到上一个字首 保存退出:q不保存退出:q!不保存强制退出:w保存:w filename保存到文件filename中:w! filename强制保存到文件filename中:wq保存退出（或者是：x 或 ZZ）:: 其他r替换光标下字符。（不进入插入模式）.重复上次操作。u撤销。cl修改当前字符cc修改当前行c$替换自光标到行尾的字符 命令&gt;G命令会增加从当前行到文档末尾处的缩进。 ##使用技巧（.的使用）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git及github的操作]]></title>
      <url>%2F2015%2F01%2Fgit-basic%2F</url>
      <content type="text"><![CDATA[Git是一个免费的、分布式的版本控制工具，或是一个强调速度快的源代码管理工具。Git诞生于2005年，最初是Linus Torvalds开发出来用于管理Linux内核的开发。 git的基本命令git clone：当你有远程git版本库，只需要在本地克隆一份： 123git clone: https://github.com/Magicer/project.git下载指定分支git clone -b &lt;branch&gt; &lt;remote_repo&gt; 例如： git clone -b 指定的分支名字 git init :也可以使用git init初始化一个本地仓库。运行了git init之后文件夹下的文件就会被进行版本控制 git add: 将当前更改或者是新增文件加入到git的索引中。 git status: git commit (-m): 提交当前工作区的修改内容。 1git commit -m &quot;提交信息&quot; git rm：从当前工作空间中和索引中删除文件 如：1git rm index.html git的分支命令git branch : 创建分支命令。（加上分支名，不加时显示所有分支） git branch -d :删除分支 git checkout : 切换分支命令。 git checkout -b： 新建并切换到该分支。 git merge gh_pages：合并分支gh_pages到当前分支]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C语言之gets()和fgets(),puts()和fputs()]]></title>
      <url>%2F2015%2F01%2Fgets-get%2F</url>
      <content type="text"><![CDATA[主要介绍gets(),fgets()和puts()fputs()的基本使用方法。 ##（一）gets()和fgets() gets() gets()函数作用是从操作系统的标准输入设备获取一个字符串。 gets()读取换行符之前（不包含换行符）的所有字符，在这些字符后添加一个空字符（\0）,然后把这个字符串交给调用它的程序。它读取换行符并将其舍弃。下一次读取会在新的一行开始。 gets()函数的构造如下： 12345char *gets(char * s)&#123; ... return (s);&#125; 可以看出gets()函数返回一个指向char的指针。但是返回的是传给他的同一个指针。 gets()可能有两个返回值，如果一切顺利，返回读入字符串的地址。如果出错或gets()遇到文件结尾，他返回一个空（或0）地址。（就是空指针NULL）。 1while(gets(name)!=NULL) fgets() gets()函数不检测目标数组是否能够容纳输入，多出来的字符简单的溢出到相邻的内存区，所以不安全。 可以用fgets()函数代替，fgets()函数读到换行符不会像gets()那样丢弃。而是存到字符串里。 使用例子： 123char name[MAX];char * ptr;ptr=fgets(name,MAX,stdin); fgets()函数有三个参数： 第一个参数：是输入的字符串。 第二个参数：来说明读入的最大字符数。如果那个参数为n，fgets()会读取最多n-1个字符或读完地一个换行符为止。 第三个参数：来说明读哪一个文件，从键盘上读取数据，可以使用stdin（代表standard input）来做参数，在stdio.h中定义。 scanf()函数 scanf()函数如果使用%s格式，字符读到下一个空白字符（空格，制表符或换行符）。可以使用%10s来表示读入十个字符或遇到第一个空白字符。 scanf()函数返回一个整数值（成功读取的项目数），或者当遇到文件结束时返回一个EOF。 puts()和fputs()puts() puts()和gets()函数的使用类似，只是用来显示字符串。只需要给出字符串的地址。puts()显示字符串时会自动添加换行符。 fputs() fputs()和puts()的区别： fputs()需要第二个参数来说明要写的文件。可以使用stdout（表示standard output）来作为参数进行输出显示，stdout在stdio.h。 和puts()不同，fputs()并不为输出自动添加换行符。 gets()丢弃输入的换行符，但是puts()为输出添加换行符。另一方面，fgets()存储输入的换行符，而fputs()也不为输出添加换行符。 123char line[49];while(fgets(line,49,stdin)) fputs(line,stdout)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C语言之gets()和fgets(),puts()和fputs()]]></title>
      <url>%2F2015%2F01%2Fgets%E5%92%8Cfget%2F</url>
      <content type="text"><![CDATA[主要介绍gets(),fgets()和puts()fputs()的基本使用方法。 （一）gets()和fgets()###gets() gets()函数作用是从操作系统的标准输入设备获取一个字符串。 gets()读取换行符之前（不包含换行符）的所有字符，在这些字符后添加一个空字符（\0）,然后把这个字符串交给调用它的程序。它读取换行符并将其舍弃。下一次读取会在新的一行开始。 gets()函数的构造如下： 12345char *gets(char * s)&#123; ... return (s);&#125; 可以看出gets()函数返回一个指向char的指针。但是返回的是传给他的同一个指针。 gets()可能有两个返回值，如果一切顺利，返回读入字符串的地址。如果出错或gets()遇到文件结尾，他返回一个空（或0）地址。（就是空指针NULL）。 1while(gets(name)!=NULL) fgets() gets()函数不检测目标数组是否能够容纳输入，多出来的字符简单的溢出到相邻的内存区，所以不安全。 可以用fgets()函数代替，fgets()函数读到换行符不会像gets()那样丢弃。而是存到字符串里。 使用例子： 123char name[MAX];char * ptr;ptr=fgets(name,MAX,stdin); fgets()函数有三个参数： 第一个参数：是输入的字符串。 第二个参数：来说明读入的最大字符数。如果那个参数为n，fgets()会读取最多n-1个字符或读完地一个换行符为止。 第三个参数：来说明读哪一个文件，从键盘上读取数据，可以使用stdin（代表standard input）来做参数，在stdio.h中定义。 ###scanf()函数 scanf()函数如果使用%s格式，字符读到下一个空白字符（空格，制表符或换行符）。可以使用%10s来表示读入十个字符或遇到第一个空白字符。 scanf()函数返回一个整数值（成功读取的项目数），或者当遇到文件结束时返回一个EOF。 puts()和fputs()puts() puts()和gets()函数的使用类似，只是用来显示字符串。只需要给出字符串的地址。puts()显示字符串时会自动添加换行符。 fputs() fputs()和puts()的区别： fputs()需要第二个参数来说明要写的文件。可以使用stdout（表示standard output）来作为参数进行输出显示，stdout在stdio.h。 和puts()不同，fputs()并不为输出自动添加换行符。 gets()丢弃输入的换行符，但是puts()为输出添加换行符。另一方面，fgets()存储输入的换行符，而fputs()也不为输出添加换行符。 123char line[49];while(fgets(line,49,stdin)) fputs(line,stdout)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux基本操作之压缩与解压命令]]></title>
      <url>%2F2015%2F01%2Flinux-basic%2F</url>
      <content type="text"><![CDATA[Linux解压命令的基本适用。zip，tar，gzip等的命令。 ##（一）zip、unzip命令 压缩文件命令zip 1234567zip 压缩文件名 源文件zip -r 压缩文件名 源目录#解压缩命令unzipunzip 压缩文件 ##（二）gzip解压缩（.gz格式）12gzip 源文件#压缩为.gz格式的压缩文件，源文件会消失。 解决方法（重定向） 1234567gzip -c 源文件 &gt; 压缩文件gzip -r 目录#压缩目录下所有的之文件，但是不能压缩目录。#解压缩：gzip -d 压缩文件#也可以：gunzip 压缩文件 ##（三）.bz2格式压缩 bzip2不能压缩目录。 123456789101112bzip2 源文件#压缩为.bz2格式，不保留源文件。bzip2 -k 源文件#压缩之后保留源文件#解压缩：bzip2 -d 压缩文件#解压缩 ，-k 保留压缩文件bunzip2 压缩文件#解压缩 ，-k 保留压缩文件 ##（四）打包命令tar命令格式：12345678910111213141516tar -zjcvf 打包文件名 源文件 -z：压缩为.tar.gz格式 -j：压缩为.tar.bz2格式 -c：打包 -v：显示过程 -f：指定打包后的文件名tar -zjxvf 打包文件名 -z：解压缩.tar.gz格式 -j：解压缩.tar.bz2格式 -x：解压缩#指定解压缩位置：tar -zxvf 压缩包.tar.gz -C 解压目录#查看压缩包，但不解压：tar -ztvf 压缩包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C语言之 typedef和define的使用]]></title>
      <url>%2F2015%2F01%2Ftypedef%E5%92%8Cdefine%2F</url>
      <content type="text"><![CDATA[c语言中typedef和define的使用 typedef和define的使用##（一）typedef的使用 typedef，使你能够为某一个类型创建自己的别名。例如： 1typedef unsigned char BYTE; 随后你就可以使用 123456 BYTE x,y[10],*z;``` ###1、结合指针的用法 ```c tyoedef char *STRING; STRING name,sign; 意思是 1char * name,*sign; ###2、使用指针时和define的区别 12#define STRING char *STRING name,sign; 被解释为 1char *name,sign; 第二个sign没有被设置为字符指针。 3、typedef和结构 例：1234 typedef struct complex&#123; float real; float imag;&#125; COMPLEXL; 这样就可以用COMPLEX代替struct complex来表示复数了。 ##（二）define的使用 1、define的通常用法#define name stuff 每当有符号那么出现时在这条指令后面时，预处理器就会把它替换成stuff。 2、使用#define可能出现副作用 #define机制包括了一个规定，允许把参数替换到文本中。 例如： #define SQUARE(x) x*x 如果在定义了之后使用SQUARE（5）结果是25; 但是如果使用 a=5; printf(&quot;%d\n&quot;,SQUARE(a+1)); 结果会是什么样呢？？也许你会说是36,可是真的是么？？？让我们分析一下。define语句后出现SQUARE(x)的地方会被替换为x*x在这个例子中a+1相当与x。所以此时愿意应为 printf(&quot;%d\n&quot;,a+1*a+1); 现在你感觉结果是多少呢？没错，是11.当然解决这个问题也很简单，加上括号不就解决了么。 #define SQUARE(x) (x)*(x) 而如果是 #define DOUBLE(x) (x)+(x) 则需要写成 #define DOUBLE(x) ((x)+(x)) 道理一样。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C语言之 typedef和define的使用]]></title>
      <url>%2F2015%2F01%2Ftypedefine%2F</url>
      <content type="text"><![CDATA[c语言中typedef和define的使用 typedef和define的使用##（一）typedef的使用 typedef，使你能够为某一个类型创建自己的别名。例如： 1typedef unsigned char BYTE; 随后你就可以使用 123456 BYTE x,y[10],*z;``` ###1、结合指针的用法 ```c tyoedef char *STRING; STRING name,sign; 意思是 1char * name,*sign; ###2、使用指针时和define的区别 12#define STRING char *STRING name,sign; 被解释为 1char *name,sign; 第二个sign没有被设置为字符指针。 ###3、typedef和结构 例： 1234 typedef struct complex&#123; float real; float imag;&#125; COMPLEXL; 这样就可以用COMPLEX代替struct complex来表示复数了。 ##（二）define的使用 ###1、define的通常用法 #define name stuff 每当有符号那么出现时在这条指令后面时，预处理器就会把它替换成stuff。 ###2、使用#define可能出现副作用 #define机制包括了一个规定，允许把参数替换到文本中。 例如： #define SQUARE(x) x*x 如果在定义了之后使用SQUARE（5）结果是25; 但是如果使用 a=5; printf(&quot;%d\n&quot;,SQUARE(a+1)); 结果会是什么样呢？？也许你会说是36,可是真的是么？？？让我们分析一下。define语句后出现SQUARE(x)的地方会被替换为x*x在这个例子中a+1相当与x。所以此时愿意应为 printf(&quot;%d\n&quot;,a+1*a+1); 现在你感觉结果是多少呢？没错，是11.当然解决这个问题也很简单，加上括号不就解决了么。 #define SQUARE(x) (x)*(x) 而如果是 #define DOUBLE(x) (x)+(x) 则需要写成 #define DOUBLE(x) ((x)+(x)) 道理一样。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown的基本使用方法]]></title>
      <url>%2F2014%2F12%2Fmarkdown-note%2F</url>
      <content type="text"><![CDATA[markdown的基本用法。 Markdown的用法笔记 （hexo）如何添加目录 按照一定的层次添加标题，目录会自动创建。 段落 段落前后都要有空行 代码段 代码段printf()在行内可以使用反引号来标记出来 只需要在代码段前面加4个空格或制表符。 也可以使用 ` bash (没有空格)` 123$ hexo generate$ hexo server$ hexo deploy 代码段（用的制表符） 强调 斜体斜体_ 粗体两个__ _强调的内容(斜体)_ --强调（粗体）--效果如下： 强调的内容 粗体强调 链接 magicer(这里是链接需要显示的内容) 格式如下，[内代表要显示的内容]，()内为链接的地址 [magicer](http://aoshizhang.com) 图片链接只需要在地址链接前面加！ 列表 用- +表示无序列表 如： 水果 零食 衣服 有序列表只需要在.前面加上数字。 苹果 香蕉 柚子a. 橘子b. 梨 表格1234| 一个普通标题 | 一个普通标题 | 一个普通标题 || ------| ------ | ------ || 短文本 | 中等文本 | 稍微长一点的文本 || 稍微长一点的文本 | 短文本 | 中等文本 | 一个普通标题 一个普通标题 一个普通标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo 配置及使用]]></title>
      <url>%2F2014%2F12%2FMy-first-Blog%2F</url>
      <content type="text"><![CDATA[用hexo搭建博客时遇到的一些问题，及部分解决方法，内容较为简短 hexo出现的问题自己创建博客 自己建博客问题就是好多，但是经过自己解决问题之后， 感觉还是很好哒。 出现的问题 修改过md文件之后识别不出来样式。暂时不知道什么原因。hexo d之后CNAME文件 丢失，导致域名无法进入 问题已解决（2014年12月27日 11:11:54）修改markdown文件后识别不出来，原因是我在source文件夹下创建了tag文件夹的格 式错误，删除后再输入后问题解决。 12$ hexo g$ hexo s hexo出现文章重复的现象 在命令窗口输入命令后，问题解决，（缓存的原因） 1$ hexo clean 常见命令 hexo g ：生成 hexo s ：运行服务 hexo n [文章名] ： 创建新文章]]></content>
    </entry>

    
  
  
</search>
